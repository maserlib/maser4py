

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>maser.utils.cdf.cdf &mdash; maser4py 0.5.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="maser4py 0.5.0 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> maser4py
          

          
          </a>

          
            
            
              <div class="version">
                0.5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../services.html">Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../utils.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../appendices.html">Troubleshooting</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">maser4py</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>maser.utils.cdf.cdf</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for maser.utils.cdf.cdf</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">ctypes.util</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">const</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: spacepy.pycdf</span>

<span class="sd">This package provides a Python interface to the Common Data Format (CDF)</span>
<span class="sd">library used for many NASA missions, available at http://cdf.gsfc.nasa.gov/. It</span>
<span class="sd">is targeted at Python 2.6+ and should work without change on either Python 2 or</span>
<span class="sd">Python 3.</span>

<span class="sd">The interface is intended to be &#39;pythonic&#39; rather than reproducing the C</span>
<span class="sd">interface. To open or close a CDF and access its variables, see the</span>
<span class="sd">:class:`CDF` class. Accessing data within the variables is via the :class:`Var`</span>
<span class="sd">class. The :data:`lib` object provides access to some routines that affect the</span>
<span class="sd">functionality of the library in general. The :mod:`~spacepy.pycdf.const` module</span>
<span class="sd">contains constants useful for accessing the underlying library.</span>


<span class="sd">The CDF C library must be properly installed in order to use this package. The</span>
<span class="sd">CDF distribution provides scripts meant to be called in a user&#39;s login scripts,</span>
<span class="sd">``definitions.B`` for bash and ``definitions.C`` for C-shell derivatives. (See</span>
<span class="sd">the installation instructions which come with the CDF library.) These will set</span>
<span class="sd">environment variables specifying the location of the library; pycdf will</span>
<span class="sd">respect these variables if they are set. Otherwise it will search the standard</span>
<span class="sd">system library path and the default installation locations for the CDF library.</span>

<span class="sd">If pycdf has trouble finding the library, try setting ``CDF_LIB`` before</span>
<span class="sd">importing the module, e.g. if the library is in ``CDF/lib`` in the user&#39;s home</span>
<span class="sd">directory:</span>

<span class="sd">&gt;&gt;&gt; import os</span>
<span class="sd">&gt;&gt;&gt; os.putenv(&quot;CDF_LIB&quot;, &quot;~/CDF/lib&quot;)</span>
<span class="sd">&gt;&gt;&gt; from spacepy import pycdf</span>

<span class="sd">If this works, make the environment setting permanent. Note that on OSX, using</span>
<span class="sd">plists to set the environment may not carry over to Python terminal sessions;</span>
<span class="sd">use ``.cshrc`` or ``.bashrc`` instead.</span>

<span class="sd">.. note::</span>

<span class="sd">   If the CDF library cannot be found, pycdf will be left in a &quot;half-imported&quot;</span>
<span class="sd">   state. You will need to restart your Python interpreter before trying the</span>
<span class="sd">   fix above.</span>

<span class="sd">.. currentmodule:: spacepy.pycdf</span>


<span class="sd">Authors: Jon Niehof</span>

<span class="sd">Institution: Los Alamos National Laboratory</span>

<span class="sd">Contact: jniehof@lanl.gov</span>


<span class="sd">Copyright 2010-2013 Los Alamos National Security, LLC.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__contact__</span> <span class="o">=</span> <span class="s1">&#39;Jon Niehof, jniehof@lanl.gov&#39;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CDF&quot;</span><span class="p">]</span>


<span class="k">try</span><span class="p">:</span>
    <span class="n">str_classes</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">str_classes</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Library</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstraction of the base CDF C library and its state.</span>

<span class="sd">    Not normally intended for end-user use. An instance of this class is</span>
<span class="sd">    created at package load time as the :data:`~spacepy.pycdf.lib` variable,</span>
<span class="sd">    providing access to the underlying C library if necessary. The CDF library</span>
<span class="sd">    itself is described in section 2.1 of the CDF user&#39;s guide, as well as the</span>
<span class="sd">    CDF C reference manual.</span>

<span class="sd">    Calling the C library directly requires knowledge of</span>
<span class="sd">    :mod:`ctypes`.</span>

<span class="sd">    Instantiating this object loads the C library, see :doc:`/pycdf` docs</span>
<span class="sd">    for details.</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~Library.call</span>
<span class="sd">        ~Library.check_status</span>
<span class="sd">        ~Library.datetime_to_epoch</span>
<span class="sd">        ~Library.datetime_to_epoch16</span>
<span class="sd">        ~Library.datetime_to_tt2000</span>
<span class="sd">        ~Library.epoch_to_datetime</span>
<span class="sd">        ~Library.epoch_to_epoch16</span>
<span class="sd">        ~Library.epoch_to_tt2000</span>
<span class="sd">        ~Library.epoch16_to_datetime</span>
<span class="sd">        ~Library.epoch16_to_epoch</span>
<span class="sd">        ~Library.epoch16_to_tt2000</span>
<span class="sd">        ~Library.set_backward</span>
<span class="sd">        supports_int8</span>
<span class="sd">        ~Library.tt2000_to_datetime</span>
<span class="sd">        ~Library.tt2000_to_epoch</span>
<span class="sd">        ~Library.tt2000_to_epoch16</span>
<span class="sd">        v_datetime_to_epoch</span>
<span class="sd">        v_datetime_to_epoch16</span>
<span class="sd">        v_datetime_to_tt2000</span>
<span class="sd">        v_epoch_to_datetime</span>
<span class="sd">        v_epoch_to_tt2000</span>
<span class="sd">        v_epoch16_to_datetime</span>
<span class="sd">        v_epoch16_to_tt2000</span>
<span class="sd">        v_tt2000_to_datetime</span>
<span class="sd">        v_tt2000_to_epoch</span>
<span class="sd">        v_tt2000_to_epoch16</span>
<span class="sd">        ~Library.version</span>

<span class="sd">    .. automethod:: call</span>
<span class="sd">    .. automethod:: check_status</span>
<span class="sd">    .. automethod:: datetime_to_epoch</span>
<span class="sd">    .. automethod:: datetime_to_epoch16</span>
<span class="sd">    .. automethod:: datetime_to_tt2000</span>
<span class="sd">    .. automethod:: epoch_to_datetime</span>
<span class="sd">    .. automethod:: epoch_to_epoch16</span>
<span class="sd">    .. automethod:: epoch_to_tt2000</span>
<span class="sd">    .. automethod:: epoch16_to_datetime</span>
<span class="sd">    .. automethod:: epoch16_to_epoch</span>
<span class="sd">    .. automethod:: epoch16_to_tt2000</span>
<span class="sd">    .. automethod:: set_backward</span>

<span class="sd">    .. attribute:: supports_int8</span>

<span class="sd">       True if this library supports INT8 and TIME_TT2000 types; else False.</span>

<span class="sd">    .. automethod:: tt2000_to_datetime</span>
<span class="sd">    .. automethod:: tt2000_to_epoch</span>
<span class="sd">    .. automethod:: tt2000_to_epoch16</span>

<span class="sd">    .. method:: v_datetime_to_epoch(datetime)</span>

<span class="sd">        A vectorized version of :meth:`datetime_to_epoch` which takes a</span>
<span class="sd">        numpy array of datetimes as input and returns an array of epochs.</span>

<span class="sd">    .. method:: v_datetime_to_epoch16(datetime)</span>

<span class="sd">        A vectorized version of :meth:`datetime_to_epoch16` which takes a</span>
<span class="sd">        numpy array of datetimes as input and returns an array of epoch16.</span>

<span class="sd">    .. method:: v_datetime_to_tt2000(datetime)</span>

<span class="sd">        A vectorized version of :meth:`datetime_to_tt2000` which takes a</span>
<span class="sd">        numpy array of datetimes as input and returns an array of TT2000.</span>

<span class="sd">    .. method:: v_epoch_to_datetime(epoch)</span>

<span class="sd">        A vectorized version of :meth:`epoch_to_datetime` which takes a</span>
<span class="sd">        numpy array of epochs as input and returns an array of datetimes.</span>

<span class="sd">    .. method:: v_epoch_to_tt2000(epoch)</span>

<span class="sd">        A vectorized version of :meth:`epoch_to_tt2000` which takes a</span>
<span class="sd">        numpy array of epochs as input and returns an array of tt2000s.</span>

<span class="sd">    .. method:: v_epoch16_to_datetime(epoch0, epoch1)</span>

<span class="sd">        A vectorized version of :meth:`epoch16_to_datetime` which takes</span>
<span class="sd">        a numpy array of epoch16 as input and returns an array of datetimes.</span>
<span class="sd">        An epoch16 is a pair of doubles; the input array&#39;s last dimension</span>
<span class="sd">        must be two (and the returned array will have one fewer dimension).</span>

<span class="sd">    .. method:: v_epoch16_to_tt2000(epoch16)</span>

<span class="sd">        A vectorized version of :meth:`epoch16_to_tt2000` which takes</span>
<span class="sd">        a numpy array of epoch16 as input and returns an array of tt2000s.</span>
<span class="sd">        An epoch16 is a pair of doubles; the input array&#39;s last dimension</span>
<span class="sd">        must be two (and the returned array will have one fewer dimension).</span>

<span class="sd">    .. method:: v_tt2000_to_datetime(tt2000)</span>

<span class="sd">        A vectorized version of :meth:`tt2000_to_datetime` which takes</span>
<span class="sd">        a numpy array of tt2000 as input and returns an array of datetimes.</span>

<span class="sd">    .. method:: v_tt2000_to_epoch(tt2000)</span>

<span class="sd">        A vectorized version of :meth:`tt2000_to_epoch` which takes</span>
<span class="sd">        a numpy array of tt2000 as input and returns an array of epochs.</span>

<span class="sd">    .. method:: v_tt2000_to_epoch16(tt2000)</span>

<span class="sd">        A vectorized version of :meth:`tt2000_to_epoch16` which takes</span>
<span class="sd">        a numpy array of tt2000 as input and returns an array of epoch16.</span>

<span class="sd">    .. attribute:: version</span>

<span class="sd">       Version of the CDF library, (version, release, increment, subincrement)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the CDF C library.</span>

<span class="sd">        Searches for the library in the order:</span>
<span class="sd">            1. Appropriately-named file in CDF_LIB</span>
<span class="sd">            2. Appropriately-named file in CDF_BASE</span>
<span class="sd">            3. Standard library search path</span>
<span class="sd">        @raise CDFError: BAD_DATA_TYPE if can&#39;t map types properly</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;CDF_TMP&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;CDF_TMP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span>

        <span class="n">libpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_lib</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="n">libpath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_2</span><span class="p">()</span>

        <span class="c1"># Get CDF version information</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_VERSION_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ver</span><span class="p">),</span>
                  <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_RELEASE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">rel</span><span class="p">),</span>
                  <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_INCREMENT_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">inc</span><span class="p">),</span>
                  <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">LIB_subINCREMENT_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sub</span><span class="p">))</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">ver</span><span class="o">.</span><span class="n">value</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">value</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span><span class="o">.</span><span class="n">value</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="p">(</span><span class="n">ver</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">sub</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_del_middle_rec_bug</span> <span class="o">=</span> <span class="n">ver</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ver</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span>
                                               <span class="p">(</span><span class="n">rel</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">or</span>
                                                <span class="p">(</span><span class="n">rel</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">inc</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supports_int8</span> <span class="o">=</span> <span class="p">(</span><span class="n">ver</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ver</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">rel</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_1</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

        <span class="n">v_epoch16_to_datetime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch16_to_datetime</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">lambda_1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v_epoch16_to_datetime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch16_to_datetime</span> <span class="o">=</span> <span class="n">lambda_1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch_to_datetime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_to_datetime</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_datetime</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_epoch</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_epoch</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
        <span class="n">v_datetime_to_epoch16</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_epoch16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># frompyfunc returns a TUPLE of the returned values,</span>
        <span class="c1"># implicitly the 0th dimension. We want everything from one</span>
        <span class="c1"># call paired, so this rolls the 0th dimension to the last</span>
        <span class="c1"># (via the second-to-last)</span>
        <span class="k">def</span> <span class="nf">_v_datetime_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span>
                <span class="n">v_datetime_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">retval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">retval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_epoch16</span> <span class="o">=</span> <span class="n">_v_datetime_to_epoch16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_tt2000</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch_to_tt2000</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_to_tt2000</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
        <span class="n">v_epoch16_to_tt2000</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch16_to_tt2000</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">lambda_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v_epoch16_to_tt2000</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch16_to_tt2000</span> <span class="o">=</span> <span class="n">lambda_2</span>
        <span class="n">v_tt2000_to_epoch16</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frompyfunc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># frompyfunc returns a TUPLE of the returned values,</span>
        <span class="c1"># implicitly the 0th dimension. We want everything from one</span>
        <span class="c1"># call paired, so this rolls the 0th dimension to the last</span>
        <span class="c1"># (via the second-to-last)</span>
        <span class="k">def</span> <span class="nf">_v_tt2000_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span>
                <span class="n">v_tt2000_to_epoch16</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">retval</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">retval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch16</span> <span class="o">=</span> <span class="n">_v_tt2000_to_epoch16</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datetime_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_datetime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_16_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_epoch16_to_tt2000</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tt2000_to_epoch16</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_tt2000_to_epoch16</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_tt2000</span>

        <span class="c1"># Default to V2 CDF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_backward</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">EPOCHbreakdown</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">]</span> <span class="o">*</span> <span class="mi">7</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH16</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH16</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> \
            <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDFsetFileBackward&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFsetFileBackward</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFsetFileBackward</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_from_UTC_parts&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_parts</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_parts</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">]</span> <span class="o">*</span> <span class="mi">9</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_to_UTC_parts&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_parts</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_parts</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">9</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_to_UTC_EPOCH&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_from_UTC_EPOCH&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_to_UTC_EPOCH16&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH16</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH16</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="p">,</span> <span class="s1">&#39;CDF_TT2000_from_UTC_EPOCH16&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH16</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> \
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH16</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_init_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdftypenames</span> <span class="o">=</span> <span class="p">{</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_BYTE&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_CHAR&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT1&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UCHAR&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UINT1&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT2&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UINT2&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT4&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_UINT4&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_INT8&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_FLOAT&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_REAL4&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_DOUBLE&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_REAL8&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_EPOCH&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_EPOCH16&#39;</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="s1">&#39;CDF_TIME_TT2000&#39;</span><span class="p">,</span>
                             <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numpytypedict</span> <span class="o">=</span> <span class="p">{</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT1</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT2</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                              <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                              <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
                              <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timetypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                          <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                          <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_find_lib</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for the CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># What the library might be named</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;win32&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;dllcdf.dll&#39;</span><span class="p">],</span>
            <span class="s1">&#39;darwin&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;libcdf.dylib&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf.dylib&#39;</span><span class="p">],</span>
            <span class="s1">&#39;linux2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;libcdf.so&#39;</span><span class="p">],</span>
            <span class="s1">&#39;linux&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;libcdf.so&#39;</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;libcdf.so&#39;</span><span class="p">])</span>

        <span class="c1"># search a directory for these names</span>
        <span class="k">def</span> <span class="nf">lambda_1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">names</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="kc">None</span>
            <span class="p">)</span>
        <span class="n">search_dir</span> <span class="o">=</span> <span class="n">lambda_1</span>

        <span class="c1"># Directories that might have the library, in desired search order</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Search the environment-specified places first</span>
        <span class="k">if</span> <span class="s1">&#39;CDF_LIB&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">dirs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;CDF_LIB&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;CDF_BASE&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">dirs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;CDF_BASE&#39;</span><span class="p">],</span> <span class="s1">&#39;lib&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
            <span class="n">libpath</span> <span class="o">=</span> <span class="n">search_dir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">libpath</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">libpath</span>

        <span class="c1"># Now give ctypes a chance</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
            <span class="n">libpath</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_library</span><span class="p">(</span><span class="s1">&#39;dllcdf.dll&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">libpath</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_library</span><span class="p">(</span><span class="s1">&#39;cdf&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">libpath</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">libpath</span>

        <span class="c1"># Failure. Check all sorts of other places.</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># default places CDF gets installed under</span>
        <span class="c1"># CDF_BASE is usually a subdir of these (with &quot;cdf&quot; in the name)</span>
        <span class="c1"># Searched in order given here!</span>
        <span class="n">cdfdists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;win32&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c:</span><span class="se">\\</span><span class="s1">CDF Distribution</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">],</span>
            <span class="s1">&#39;darwin&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;/Applications/&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)],</span>
            <span class="s1">&#39;linux2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;/usr/local/&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)],</span>
            <span class="s1">&#39;linux&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;/usr/local/&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">)],</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="ow">in</span> <span class="n">cdfdists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cdfdist</span> <span class="ow">in</span> <span class="n">cdfdists</span><span class="p">[</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">cdfdist</span><span class="p">):</span>
                    <span class="n">cand</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">cdfdist</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cdf&#39;</span><span class="p">:</span>
                            <span class="c1"># checking src in case BUILT but not INSTALLED</span>
                            <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lib&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="s1">&#39;lib&#39;</span><span class="p">)]:</span>
                                <span class="n">libdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cdfdist</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">subdir</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">libdir</span><span class="p">):</span>
                                    <span class="n">cand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">libdir</span><span class="p">)</span>
                    <span class="c1"># Sort reverse, so new versions are first FOR THIS cdfdist</span>
                    <span class="n">dirs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">cand</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># LD_LIBRARY_PATH for a last ditch</span>
        <span class="k">if</span> <span class="s1">&#39;LD_LIBRARY_PATH&#39;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
            <span class="n">dirs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LD_LIBRARY_PATH&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">pathsep</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
            <span class="n">libpath</span> <span class="o">=</span> <span class="n">search_dir</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">libpath</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">libpath</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s1">&#39;Cannot find CDF C library. &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;Try os.putenv(&quot;CDF_LIB&quot;, library_directory) &#39;</span> <span class="o">+</span>
            <span class="s1">&#39;before import.&#39;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise exception or warning based on return status of CDF call</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        status : int</span>
<span class="sd">            status returned by the C library</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        ignore : sequence of ctypes.c_long</span>
<span class="sd">            CDF statuses to ignore. If any of these is returned by CDF library,</span>
<span class="sd">            any related warnings or exceptions will *not* be raised.</span>
<span class="sd">            (Default none).</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if status &lt; CDF_WARN, indicating an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF_WARN &lt;= status &lt; CDF_OK, indicating a warning.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            status (unchanged)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_OK</span> <span class="ow">or</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">status</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_WARN</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warning</span> <span class="o">=</span> <span class="n">CDFWarning</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
            <span class="n">warning</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call the CDF internal interface</span>

<span class="sd">        Passes all parameters directly through to the CDFlib routine of the</span>
<span class="sd">        CDF library&#39;s C internal interface. Checks the return value with</span>
<span class="sd">        :meth:`check_status`.</span>

<span class="sd">        Terminal NULL is automatically added to args.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        args : various, see :mod:`ctypes`</span>
<span class="sd">            Passed directly to the CDF library interface. Useful</span>
<span class="sd">            constants are defined in the :mod:`~pycdf.const` module.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        ignore : sequence of CDF statuses</span>
<span class="sd">            sequence of CDF statuses to ignore. If any of these</span>
<span class="sd">            is returned by CDF library, any related warnings or</span>
<span class="sd">            exceptions will *not* be raised.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            CDF status from the library</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;ignore&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="p">(</span>
                <span class="o">*</span><span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NULL_</span><span class="p">,</span> <span class="p">))</span>
                <span class="p">),</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ignore&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="p">(</span>
                <span class="o">*</span><span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NULL_</span><span class="p">,</span> <span class="p">))</span>
                <span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_backward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set backward compatibility mode for new CDFs</span>

<span class="sd">        Unless backward compatible mode is set, CDF files created by</span>
<span class="sd">        the version 3 library can not be read by V2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        backward : boolean</span>
<span class="sd">            Set backward compatible mode if True; clear it if False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        ValueError : if backward=False and underlying CDF library is V2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">backward</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot disable backward-compatible mode for CDF &#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;version 2.&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFsetFileBackward</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BACKWARDFILEon</span> <span class="k">if</span> <span class="n">backward</span>
                                         <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">BACKWARDFILEoff</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">epoch_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF epoch value to a datetime</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch : float</span>
<span class="sd">            epoch value from CDF</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :class:`datetime.datetime`</span>
<span class="sd">            date and time corresponding to epoch. Invalid values are set to</span>
<span class="sd">            usual epoch invalid value, i.e. last moment of year 9999.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch_to_datetime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yyyy</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hh</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">EPOCHbreakdown</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">epoch</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">yyyy</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hh</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="nb">min</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">msec</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">yyyy</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999000</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">msec</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">datetime_to_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Python datetime to a CDF Epoch value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        dt : :class:`datetime.datetime`</span>
<span class="sd">            date and time to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : float</span>
<span class="sd">            epoch corresponding to dt</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_datetime_to_epoch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span>
        <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">micro</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span>
        <span class="k">if</span> <span class="n">micro</span> <span class="o">&gt;=</span> <span class="mi">500</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">&lt;</span> <span class="mi">9999</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">+=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
                                          <span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
                                          <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">epoch16_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF epoch16 value to a datetime</span>

<span class="sd">        .. note::</span>
<span class="sd">            The call signature has changed since SpacePy 0.1.2. Formerly</span>
<span class="sd">            this method took a single argument with two values; now it</span>
<span class="sd">            requires two arguments (one for each value). To convert existing</span>
<span class="sd">            code, replace ``epoch16_to_datetime(epoch)`` with</span>
<span class="sd">            ``epoch16_to_datetime(*epoch)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch0 : float</span>
<span class="sd">            epoch16 value from CDF, first half</span>
<span class="sd">        epoch1 : float</span>
<span class="sd">            epoch16 value from CDF, second half</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :class:`datetime.datetime`</span>
<span class="sd">            date and time corresponding to epoch. Invalid values are set to</span>
<span class="sd">            usual epoch invalid value, i.e. last moment of year 9999.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch16_to_datetime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yyyy</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hh</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">usec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nsec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">psec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">EPOCH16breakdown</span><span class="p">(</span>
            <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)(</span><span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">yyyy</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hh</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="nb">min</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sec</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">msec</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">usec</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">nsec</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">psec</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">yyyy</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="n">micro</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">msec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">usec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">nsec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">psec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e6</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">micro</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">micro</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">micro</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                    <span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="n">micro</span> <span class="o">-</span> <span class="n">add_sec</span> <span class="o">*</span> <span class="mi">1000000</span>
                <span class="p">)</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">add_sec</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">MAXYEAR</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>
                                         <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span>
                                         <span class="mi">999999</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">datetime_to_epoch16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Python datetime to a CDF Epoch16 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        dt :  :class:`datetime.datetime`</span>
<span class="sd">            date and time to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : list of float</span>
<span class="sd">            epoch16 corresponding to dt</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_datetime_to_epoch16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span>
        <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">epoch16</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">computeEPOCH16</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
                                     <span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
                                     <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">),</span>
                                     <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                     <span class="n">epoch16</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">epoch16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">epoch16</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">epoch_to_epoch16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF EPOCH to a CDF EPOCH16 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch : double</span>
<span class="sd">            EPOCH to convert. Lists and numpy arrays are acceptable.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : (double, double)</span>
<span class="sd">            EPOCH16 corresponding to epoch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span>
        <span class="c1"># ugly numpy stuff, probably a better way....</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="mf">1000.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">newshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">newshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">epoch16_to_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch16</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF EPOCH16 to a CDF EPOCH value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch16 : (double, double)</span>
<span class="sd">            EPOCH16 to convert. Lists and numpy arrays are acceptable.</span>
<span class="sd">            LAST dimension should be 2: the two pairs of EPOCH16</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : double</span>
<span class="sd">            EPOCH corresponding to epoch16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">epoch16</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tt2000_to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tt2000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF TT2000 value to a datetime</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although TT2000 values support leapseconds, Python&#39;s datetime</span>
<span class="sd">            object does not. Any times after 23:59:59.999999 will</span>
<span class="sd">            be truncated to 23:59:59.999999.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        tt2000 : int</span>
<span class="sd">            TT2000 value from CDF</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :class:`datetime.datetime`</span>
<span class="sd">            date and time corresponding to epoch. Invalid values are set to</span>
<span class="sd">            usual epoch invalid value, i.e. last moment of year 9999.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_tt2000_to_datetime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yyyy</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hh</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">msec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">usec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nsec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_parts</span><span class="p">(</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">(</span><span class="n">tt2000</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">yyyy</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mm</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dd</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hh</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="nb">min</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">sec</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">msec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">usec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">nsec</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">yyyy</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sec</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sec</span> <span class="o">&gt;=</span> <span class="mi">60</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>
        <span class="n">micro</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">msec</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">usec</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">nsec</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">micro</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">sec</span><span class="p">,</span> <span class="n">micro</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">micro</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">yyyy</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mm</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">hh</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">sec</span><span class="p">,</span>
                    <span class="n">micro</span> <span class="o">-</span> <span class="n">add_sec</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">add_sec</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">MAXYEAR</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>
                                         <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">999999</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">datetime_to_tt2000</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a Python datetime to a CDF TT2000 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        dt :  :class:`datetime.datetime`</span>
<span class="sd">            date and time to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            tt2000 corresponding to dt</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_datetime_to_tt2000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">dt</span><span class="o">.</span><span class="n">utcoffset</span><span class="p">()</span>
        <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_parts</span><span class="p">(</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">),</span>
            <span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">epoch_to_tt2000</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF EPOCH to a CDF TT2000 value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch : double</span>
<span class="sd">            EPOCH to convert</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            tt2000 corresponding to epoch</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch_to_tt2000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tt2000_to_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tt2000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF TT2000 value to a CDF EPOCH</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although TT2000 values support leapseconds, CDF EPOCH values</span>
<span class="sd">            do not. Times during leapseconds are rounded up to beginning</span>
<span class="sd">            of the next day.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        tt2000 : int</span>
<span class="sd">            TT2000 value from CDF</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : double</span>
<span class="sd">            EPOCH corresponding to the TT2000 input time</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_tt2000_to_epoch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH</span><span class="p">(</span><span class="n">tt2000</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">epoch16_to_tt2000</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF epoch16 value to TT2000</span>

<span class="sd">        .. note::</span>
<span class="sd">            Because TT2000 does not support picoseconds, the picoseconds</span>
<span class="sd">            value in epoch is ignored (i.e., truncated.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        epoch0 : float</span>
<span class="sd">            epoch16 value from CDF, first half</span>
<span class="sd">        epoch1 : float</span>
<span class="sd">            epoch16 value from CDF, second half</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : long</span>
<span class="sd">            TT2000 corresponding to epoch.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_epoch16_to_tt2000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_from_UTC_EPOCH16</span><span class="p">(</span>
            <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)(</span><span class="n">epoch0</span><span class="p">,</span> <span class="n">epoch1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">tt2000_to_epoch16</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tt2000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a CDF TT2000 value to a CDF EPOCH16</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although TT2000 values support leapseconds, CDF EPOCH16 values</span>
<span class="sd">            do not. Times during leapseconds are rounded up to beginning</span>
<span class="sd">            of the next day.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        tt2000 : int</span>
<span class="sd">            TT2000 value from CDF</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        EpochError : if input invalid</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : double, double</span>
<span class="sd">            EPOCH16 corresponding to the TT2000 input time</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        v_tt2000_to_epoch16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epoch16</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDF_TT2000_to_UTC_EPOCH16</span><span class="p">(</span>
            <span class="n">tt2000</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_ctypes</span><span class="p">(</span><span class="n">epoch16</span><span class="p">))</span>
        <span class="c1"># without this, vectorized version breaks</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">epoch16</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">epoch16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">epoch16</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_bad_tt2000</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience function for complaining that TT2000 not supported&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;TT2000 functions require CDF library 3.4.0 or later&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="n">lib</span> <span class="o">=</span> <span class="n">Library</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;Module global library object.</span>

<span class="sd">    Initalized at module load time so all classes have ready</span>
<span class="sd">    access to the CDF library and a common state. E.g:</span>
<span class="sd">        &gt;&gt;&gt; from spacepy import pycdf</span>
<span class="sd">        &gt;&gt;&gt; pycdf.lib.version</span>
<span class="sd">            (3, 3, 0, &#39; &#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;sphinx&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;CDF library did not load. &#39;</span>
                      <span class="s1">&#39;You appear to be building docs, so ignoring this error.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>


<span class="k">class</span> <span class="nc">CDFException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for errors or warnings in the CDF library.</span>

<span class="sd">    Not normally used directly, but in subclasses :class:`CDFError`</span>
<span class="sd">    and :class:`CDFWarning`.</span>

<span class="sd">    Error messages provided by this class are looked up from the underlying</span>
<span class="sd">    C library.</span>

<span class="sd">    .. comment:</span>
<span class="sd">        @ivar status: CDF library status code</span>
<span class="sd">        @type status: ctypes.c_long</span>
<span class="sd">        @ivar string: CDF library error message for L{status}</span>
<span class="sd">        @type string: string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a CDF Exception</span>

<span class="sd">        Uses CDF C library to look up an appropriate error message.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        status : ctypes.c_long</span>
<span class="sd">            CDF status</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;CDF error &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, unable to get details.&#39;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_STATUSTEXT_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">_library</span><span class="o">.</span><span class="n">CDFlib</span><span class="p">(</span>
                <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span>
                <span class="n">const</span><span class="o">.</span><span class="n">CDF_STATUS_</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">status</span><span class="p">),</span>
                <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span>
                <span class="n">const</span><span class="o">.</span><span class="n">STATUS_TEXT_</span><span class="p">,</span>
                <span class="n">message</span><span class="p">,</span>
                <span class="n">const</span><span class="o">.</span><span class="n">NULL_</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">retval</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_OK</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">value</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">string</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Error string associated with the library error.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : str</span>
<span class="sd">            Error message from the CDF library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">string</span>


<span class="k">class</span> <span class="nc">CDFError</span><span class="p">(</span><span class="n">CDFException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised for an error in the CDF library.&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">CDFWarning</span><span class="p">(</span><span class="n">CDFException</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for a warning in the CDF library.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Issues a warning based on the information stored in my exception</span>

<span class="sd">        Intended for use in check_status or similar wrapper function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        level : int</span>
<span class="sd">            optional (default 3), how far up the stack the warning should</span>
<span class="sd">            be reported. Passed directly to :class:`warnings.warn`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">EpochError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used for errors in epoch routines&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_compress</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">comptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set or check the compression of a :py:class:`pycdf.CDF` or</span>
<span class="sd">    :py:class:`pycdf.Var`</span>

<span class="sd">    @param obj: object on which to set or check compression</span>
<span class="sd">    @type obj: :py:class:`pycdf.CDF` or :py:class:`pycdf.Var`</span>
<span class="sd">    @param comptype: type of compression to change to, see CDF C reference</span>
<span class="sd">        manual section 4.10. Constants for this parameter are in</span>
<span class="sd">        :py:mod:`pycdf.const`. If not specified, will not change compression.</span>
<span class="sd">    @type comptype: ctypes.c_long</span>
<span class="sd">    @param param: Compression parameter, see CDF CRM 4.10 and</span>
<span class="sd">        :py:mod:`pycdf.const`. If not specified, will choose reasonable default</span>
<span class="sd">        (5 for gzip; other types have only one possible parameter.)</span>
<span class="sd">    @type param: ctypes.c_long</span>
<span class="sd">    @return: (comptype, param) currently in effect</span>
<span class="sd">    @rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">CDF</span><span class="p">):</span>
        <span class="n">COMPRESSION_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_COMPRESSION_</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
        <span class="n">COMPRESSION_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_COMPRESSION_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify a CDF or Var type.&#39;</span><span class="p">)</span>

    <span class="n">validparams</span> <span class="o">=</span> <span class="p">{</span><span class="n">const</span><span class="o">.</span><span class="n">NO_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">RLE_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">RLE_OF_ZEROs</span><span class="p">],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">HUFF_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                       <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">OPTIMAL_ENCODING_TREES</span><span class="p">],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">AHUFF_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                       <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">OPTIMAL_ENCODING_TREES</span><span class="p">],</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GZIP_COMPRESSION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">9</span><span class="p">),</span>
                                                  <span class="p">],</span>
                   <span class="p">}</span>
    <span class="n">comptypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">NO_COMPRESSION</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">RLE_COMPRESSION</span><span class="p">,</span>
                 <span class="n">const</span><span class="o">.</span><span class="n">HUFF_COMPRESSION</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">AHUFF_COMPRESSION</span><span class="p">,</span>
                 <span class="n">const</span><span class="o">.</span><span class="n">GZIP_COMPRESSION</span><span class="p">]</span>
    <span class="n">comptypevalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comptypes</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">comptype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">comptype</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
            <span class="n">comptype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">comptype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comptype</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">validparams</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_COMPRESSION</span><span class="p">)</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">validparams</span><span class="p">[</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">paramlist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)(</span><span class="n">param</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span>
            <span class="n">COMPRESSION_</span><span class="p">,</span>
            <span class="n">comptype</span><span class="p">,</span>
            <span class="n">paramlist</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span>
              <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_PARMS</span><span class="p">)(</span><span class="o">*</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_PARMS</span><span class="p">))</span>
    <span class="n">comptype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">percent</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
        <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span>
        <span class="n">COMPRESSION_</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">comptype</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">percent</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">comptype</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comptypevalues</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_COMPRESSION</span><span class="p">)</span>
    <span class="n">validparamvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">validparams</span><span class="p">[</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">validparamvalues</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_COMPRESSION_PARM</span><span class="p">)</span>
    <span class="n">comptype</span> <span class="o">=</span> <span class="n">comptypes</span><span class="p">[</span><span class="n">comptypevalues</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">comptype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">RLE_COMPRESSION</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">HUFF_COMPRESSION</span><span class="p">,</span>
                    <span class="n">const</span><span class="o">.</span><span class="n">AHUFF_COMPRESSION</span><span class="p">):</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">validparams</span><span class="p">[</span><span class="n">comptype</span><span class="o">.</span><span class="n">value</span><span class="p">][</span><span class="n">validparamvalues</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">param</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">comptype</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>


<div class="viewcode-block" id="CDF"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF">[docs]</a><span class="k">class</span> <span class="nc">CDF</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Python object representing a CDF file.</span>

<span class="sd">    Open or create a CDF file by creating an object of this class.</span>

<span class="sd">    .. codeauthor:: Jon Niehof &lt;jniehof@lanl.gov&gt;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>
<span class="sd">    pathname : string</span>
<span class="sd">        name of the file to open or create</span>
<span class="sd">    masterpath : string</span>
<span class="sd">        name of the master CDF file to use in creating</span>
<span class="sd">        a new file. If not provided, an existing file is</span>
<span class="sd">        opened; if provided but evaluates to ``False``</span>
<span class="sd">        (e.g., ``&#39;&#39;``), an empty new CDF is created.</span>

<span class="sd">    Raises</span>
<span class="sd">    ======</span>
<span class="sd">    CDFError</span>
<span class="sd">        if CDF library reports an error</span>

<span class="sd">    Warns</span>
<span class="sd">    =====</span>
<span class="sd">    CDFWarning</span>
<span class="sd">        if CDF library reports a warning and interpreter</span>
<span class="sd">        is set to error on warnings.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    Open a CDF by creating a CDF object, e.g.:</span>
<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;)</span>
<span class="sd">    Be sure to :meth:`close` or :meth:`save` when</span>
<span class="sd">    done.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Existing CDF files are opened read-only by default, see</span>
<span class="sd">        :meth:`readonly` to change.</span>

<span class="sd">    CDF supports the `with</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/inputoutput.html#methods-of-file-objects&gt;`_</span>
<span class="sd">    keyword, like other file objects, so:</span>
<span class="sd">        &gt;&gt;&gt; with pycdf.CDF(&#39;cdf_filename.cdf&#39;) as cdffile:</span>
<span class="sd">        ...     #do brilliant things with the CDF</span>
<span class="sd">    will open the CDF, execute the indented statements, and close the CDF when</span>
<span class="sd">    finished or when an error occurs. The `python docs</span>
<span class="sd">    &lt;http://docs.python.org/reference/compound_stmts.html#with&gt;`_ include more</span>
<span class="sd">    detail on this &#39;context manager&#39; ability.</span>

<span class="sd">    CDF objects behave like a python</span>
<span class="sd">    `dictionary</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/datastructures.html#dictionaries&gt;`_,</span>
<span class="sd">    where the keys are names of variables in the CDF, and the values,</span>
<span class="sd">    :class:`Var` objects. As a dictionary, they are also `iterable</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/classes.html#iterators&gt;`_ and it is easy</span>
<span class="sd">    to loop over all of the variables in a file. Some examples:</span>
<span class="sd">      #. List the names of all variables in the open CDF ``cdffile``:</span>
<span class="sd">             &gt;&gt;&gt; cdffile.keys()</span>
<span class="sd">         Or:</span>
<span class="sd">             &gt;&gt;&gt; for k in cdffile:</span>
<span class="sd">             ...     print(k)</span>
<span class="sd">      #. Get a :class:`Var` object corresponding to the variable</span>
<span class="sd">         named ``Epoch``:</span>
<span class="sd">             &gt;&gt;&gt; epoch = cdffile[&#39;Epoch&#39;]</span>
<span class="sd">      #. Determine if a CDF contains a variable named ``B_GSE``:</span>
<span class="sd">             &gt;&gt;&gt; if &#39;B_GSE&#39; in cdffile:</span>
<span class="sd">             ...     print(&#39;B_GSE is in the file&#39;)</span>
<span class="sd">             ... else:</span>
<span class="sd">             ...     print(&#39;B_GSE is not in the file&#39;)</span>
<span class="sd">      #. Find how many variables are in the file:</span>
<span class="sd">             &gt;&gt;&gt; print(len(cdffile))</span>
<span class="sd">      #. Delete the variable ``Epoch`` from the open CDF file ``cdffile``:</span>
<span class="sd">            &gt;&gt;&gt; del cdffile[&#39;Epoch&#39;]</span>
<span class="sd">      #. Display a summary of variables and types in open CDF file ``cdffile``:</span>
<span class="sd">            &gt;&gt;&gt; print(cdffile)</span>
<span class="sd">      #. Open the CDF named ``cdf_filename.cdf``, read *all* the data from all</span>
<span class="sd">         variables into dictionary ``data``, and close it when done or if an</span>
<span class="sd">         error occurs:</span>
<span class="sd">             &gt;&gt;&gt; with pycdf.CDF(&#39;cdf_filename.cdf&#39;) as cdffile:</span>
<span class="sd">             ...     data = cdffile.copy()</span>
<span class="sd">    This last example can be very inefficient as it reads the entire CDF.</span>
<span class="sd">    Normally it&#39;s better to treat the CDF as a dictionary and access only</span>
<span class="sd">    the data needed, which will be pulled transparently from disc. See</span>
<span class="sd">    :class:`Var` for more subtle examples.</span>

<span class="sd">    Potentially useful dictionary methods and related functions:</span>
<span class="sd">      - `in &lt;http://docs.python.org/reference/expressions.html#in&gt;`_</span>
<span class="sd">      - `keys</span>
<span class="sd">      &lt;http://docs.python.org/tutorial/datastructures.html#dictionaries&gt;`_</span>
<span class="sd">      - :py:func:`len`</span>
<span class="sd">      - `list comprehensions</span>
<span class="sd">        &lt;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&gt;`_</span>
<span class="sd">      - :py:func:`sorted`</span>
<span class="sd">      - :py:func:`~spacepy.toolbox.dictree`</span>

<span class="sd">    The CDF user&#39;s guide section 2.2 has more background information on CDF</span>
<span class="sd">    files.</span>

<span class="sd">    The :attr:`~CDF.attrs` Python attribute acts as a dictionary</span>
<span class="sd">    referencing CDF attributes (do not confuse the two); all the</span>
<span class="sd">    dictionary methods above also work on the attribute dictionary.</span>
<span class="sd">    See :class:`gAttrList` for more on the dictionary of global</span>
<span class="sd">    attributes.</span>

<span class="sd">    Creating a new CDF from a master (skeleton) CDF has similar syntax to</span>
<span class="sd">    opening one:</span>
<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;, &#39;master_cdf_filename.cdf&#39;)</span>
<span class="sd">    This creates and opens ``cdf_filename.cdf`` as a copy of</span>
<span class="sd">    ``master_cdf_filename.cdf``.</span>

<span class="sd">    Using a skeleton CDF is recommended over making a CDF entirely from</span>
<span class="sd">    scratch, but this is possible by specifying a blank master:</span>
<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;, &#39;&#39;)</span>

<span class="sd">    When CDFs are created in this way, they are opened read-write, see</span>
<span class="sd">    :py:meth:`readonly` to change.</span>

<span class="sd">    By default, new CDFs (without a master) are created in version 2</span>
<span class="sd">    (backward-compatible) format. To create a version 3 CDF, use</span>
<span class="sd">    :meth:`Library.set_backward`:</span>
<span class="sd">        &gt;&gt;&gt; pycdf.lib.set_backward(False)</span>
<span class="sd">        &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;, &#39;&#39;)</span>

<span class="sd">    Add variables by direct assignment, which will automatically set type</span>
<span class="sd">    and dimension based on the data provided:</span>
<span class="sd">        &gt;&gt;&gt; cdffile[&#39;new_variable_name&#39;] = [1, 2, 3, 4]</span>
<span class="sd">    or, if more control is needed over the type and dimensions, use</span>
<span class="sd">    :py:meth:`new`.</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~CDF.attrs</span>
<span class="sd">        ~CDF.backward</span>
<span class="sd">        ~CDF.checksum</span>
<span class="sd">        ~CDF.clone</span>
<span class="sd">        ~CDF.close</span>
<span class="sd">        ~CDF.col_major</span>
<span class="sd">        ~CDF.compress</span>
<span class="sd">        ~CDF.copy</span>
<span class="sd">        ~CDF.from_data</span>
<span class="sd">        ~CDF.new</span>
<span class="sd">        ~CDF.raw_var</span>
<span class="sd">        ~CDF.readonly</span>
<span class="sd">        ~CDF.save</span>
<span class="sd">        ~CDF.version</span>

<span class="sd">    .. attribute:: CDF.attrs</span>

<span class="sd">       Global attributes for this CDF in a dict-like format.</span>
<span class="sd">       See :class:`gAttrList` for details.</span>

<span class="sd">    .. attribute:: CDF.backward</span>

<span class="sd">       True if this CDF was created in backward-compatible mode</span>
<span class="sd">       (for opening with CDF library before 3.x)</span>
<span class="sd">    .. automethod:: checksum</span>
<span class="sd">    .. automethod:: clone</span>
<span class="sd">    .. automethod:: close</span>
<span class="sd">    .. automethod:: col_major</span>
<span class="sd">    .. automethod:: compress</span>
<span class="sd">    .. automethod:: copy</span>
<span class="sd">    .. automethod:: from_data</span>
<span class="sd">    .. automethod:: new</span>
<span class="sd">    .. automethod:: raw_var</span>
<span class="sd">    .. automethod:: readonly</span>
<span class="sd">    .. automethod:: save</span>
<span class="sd">    .. automethod:: version</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">masterpath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open or create a CDF file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        pathname : string</span>
<span class="sd">            name of the file to open or create</span>
<span class="sd">        masterpath : string</span>
<span class="sd">            name of the master CDF file to use in creating</span>
<span class="sd">            a new file. If not provided, an existing file is</span>
<span class="sd">            opened; if provided but evaluates to ``False``</span>
<span class="sd">            (e.g., ``&#39;&#39;``), an empty new CDF is created.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError</span>
<span class="sd">            if CDF library reports an error</span>
<span class="sd">        CDFWarning</span>
<span class="sd">            if CDF library reports a warning and interpreter</span>
<span class="sd">            is set to error on warnings.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        Open a CDF by creating a CDF object, e.g.:</span>
<span class="sd">            &gt;&gt;&gt; cdffile = pycdf.CDF(&#39;cdf_filename.cdf&#39;)</span>
<span class="sd">        Be sure to :py:meth:`pycdf.CDF.close` or :py:meth:`pycdf.CDF.save`</span>
<span class="sd">        when done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="o">=</span> <span class="n">pathname</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;pathname must be string-like: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">masterpath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">masterpath</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_master</span><span class="p">(</span><span class="n">masterpath</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create</span><span class="p">()</span>
        <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_zMODE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">gAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Destructor; called when CDF object is destroyed.</span>

<span class="sd">        Close CDF file if there is still a valid handle.</span>
<span class="sd">        .. note::</span>
<span class="sd">            To avoid data loss, explicitly call :py:meth:`pycdf.CDF.close`</span>
<span class="sd">            or :py:meth:`pycdf.CDF.save`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a zVariable in this CDF, by name or number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : string or int</span>
<span class="sd">            Name or number of the CDF variable</span>
<span class="sd">        .. note:</span>
<span class="sd">            Variable numbers may change if variables are added or removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        Delete the variable ``Epoch`` from the open CDF file ``cdffile``.</span>
<span class="sd">            &gt;&gt;&gt; del cdffile[&#39;Epoch&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context manager entrance function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context manager exit function.</span>

<span class="sd">        Close CDF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets a zVariable in this CDF, by name or number</span>

<span class="sd">        The CDF acts like a dict</span>

<span class="sd">        @param name: Name or number of the CDF variable</span>
<span class="sd">        @type name: string or int</span>
<span class="sd">        @return: CDF variable named or numbered L{name}</span>
<span class="sd">        @rtype: :py:class:`pycdf.Var`</span>
<span class="sd">        @raise KeyError: for pretty much any problem in lookup</span>
<span class="sd">        @note: variable numbers may change if variables are added or removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes data to a zVariable in this CDF</span>

<span class="sd">        If the zVariable does not exist, will create one matching</span>
<span class="sd">        L{data}. If it does exist, will attempt to write L{data}</span>
<span class="sd">        to it without changing the type or dimensions.</span>

<span class="sd">        @param name: name or number of the variable to write</span>
<span class="sd">        @type name: str or int</span>
<span class="sd">        @param data: data to write, or a :py:class:`pycdf.Var` to copy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Var</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;attrs&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over zVars in CDF</span>

<span class="sd">        Iterators for dicts return keys</span>
<span class="sd">        @note: Returned in variable-number order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">():</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
                <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements &#39;length&#39; of CDF (number of zVars)</span>

<span class="sd">        @return: number of zVars in the CDF</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMzVARS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines whether a particular variable name is in the CDF</span>

<span class="sd">        @note: Essentially an efficiency function; L{__iter__} is called</span>
<span class="sd">               if this isn&#39;t defined</span>
<span class="sd">        @param key: key/variable name to check</span>
<span class="sd">        @type key: string</span>
<span class="sd">        @return: True if L{key} is the name of a variable in CDF, else False</span>
<span class="sd">        @rtype: Boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">key</span>
            <span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: NO_SUCH_VAR: Named variable not found in this CDF.&quot;</span>
            <span class="k">if</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of CDF</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy of the</span>
<span class="sd">        CDF, so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: all the data in this list of attributes</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;CDF:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the CDF</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create a :py:class:`pycdf.CDF`, just the names, types, and</span>
<span class="sd">        sizes of all variables. (Attributes are not listed.)</span>

<span class="sd">        @return: description of the variables in the CDF</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                              <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
            <span class="c1"># can get away with this sort because second value in tuple isn&#39;t</span>
            <span class="c1"># compared unless first are different, and variable name is unique.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;Closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Opens the CDF file (called on init)</span>

<span class="sd">        Will open an existing CDF file read/write.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        .. note:</span>
<span class="sd">            Not intended for direct call; pass parameters to</span>
<span class="sd">            :py:class:`pycdf.CDF` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">OPEN_</span><span class="p">,</span>
            <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">readonly</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates (and opens) a new CDF file</span>

<span class="sd">        Created at ``pathname``.</span>
<span class="sd">        Assumes zero-dimension r variables</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        .. note:</span>
<span class="sd">            Not intended for direct call; pass parameters to</span>
<span class="sd">            :py:class:`pycdf.CDF` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">CREATE_</span><span class="p">,</span>
            <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_from_master</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new CDF from a master CDF file</span>

<span class="sd">        ``master_path`` is copied to ``pathname`` and opened.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        master_path : string</span>
<span class="sd">            location of the master CDF file</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        .. note:</span>
<span class="sd">            Not intended for direct call; pass parameters to</span>
<span class="sd">            :py:class:`pycdf.CDF` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EXISTS</span><span class="p">)</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">master_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">readonly</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="CDF.from_data"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.from_data">[docs]</a>    <span class="k">def</span> <span class="nf">from_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new CDF file from a SpaceData object or similar</span>

<span class="sd">        The CDF named ``filename`` is created, opened, filled with the</span>
<span class="sd">        contents of ``sd`` (including attributes), and closed.</span>

<span class="sd">        ``sd`` should be a dictionary-like object; each key will be made</span>
<span class="sd">        into a variable name. An attribute called ``attrs``, if it exists,</span>
<span class="sd">        will be made into global attributes for the CDF.</span>

<span class="sd">        Each value of ``sd`` should be array-like and will be used as</span>
<span class="sd">        the contents of the variable; an attribute called ``attrs``, if</span>
<span class="sd">        it exists, will be made into attributes for that variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">            name of the file to create</span>
<span class="sd">        sd : spacepy.datamodel.SpaceData</span>
<span class="sd">            data to put in the CDF. This structure cannot be nested,</span>
<span class="sd">            i.e., it must contain only :class:`~spacepy.datamodel.dmarray`</span>
<span class="sd">            and no :class:`~spacepy.datamodel.Spacedata` objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">cls</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cdffile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sd</span><span class="p">:</span>
                <span class="n">cdffile</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">cdffile</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select this CDF as current and call the CDF internal interface</span>

<span class="sd">        Adds call to select this CDF to L{args} and passes all parameters</span>
<span class="sd">        directly through to the CDFlib routine of the CDF library&#39;s C internal</span>
<span class="sd">        interface. Checks the return value with L{Library.check_status}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        args : various, see :py:mod:`ctypes`.</span>
<span class="sd">            Passed directly to the CDF library interface. Useful</span>
<span class="sd">            constants are defined in the :doc:`const &lt;pycdf_const&gt;`</span>
<span class="sd">            module of this package.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : ctypes.c_long</span>
<span class="sd">            CDF status from the library</span>

<span class="sd">        .. note:</span>
<span class="sd">            Terminal NULL_ is automatically added to ``args``.</span>
<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>
<span class="sd">        CDFWarning : if CDF library reports a warning and interpreter</span>
<span class="sd">                     is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="p">,</span>
                        <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="CDF.clone"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zVar</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clone a zVariable (from another CDF or this) into this CDF</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        zVar : :py:class:`Var`</span>
<span class="sd">            variable to clone</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the new variable (default: name of the original)</span>
<span class="sd">        data : boolean (optional)</span>
<span class="sd">            Copy data, or only type, dimensions, variance, attributes?</span>
<span class="sd">            (default: True, copy data as well)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">zVar</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">recVary</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">rv</span><span class="p">(),</span>
                 <span class="n">dimVarys</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">dv</span><span class="p">(),</span> <span class="n">dims</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">(),</span>
                 <span class="n">n_elements</span><span class="o">=</span><span class="n">zVar</span><span class="o">.</span><span class="n">_nelems</span><span class="p">())</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="o">*</span><span class="n">zVar</span><span class="o">.</span><span class="n">compress</span><span class="p">())</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">zVar</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">zVar</span><span class="o">.</span><span class="n">_raw</span>
            <span class="n">zVar</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw_var</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">zVar</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
            <span class="n">zVar</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">r</span></div>

<div class="viewcode-block" id="CDF.col_major"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.col_major">[docs]</a>    <span class="k">def</span> <span class="nf">col_major</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_col</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the majority of this CDF file</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_col : boolean</span>
<span class="sd">            Specify True to change to column-major, False to change to</span>
<span class="sd">            row major, or do not specify to check the majority</span>
<span class="sd">            rather than changing it.</span>
<span class="sd">            (default is check only)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : boolean</span>
<span class="sd">            True if column-major, false if row-major</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_maj</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">COLUMN_MAJOR</span> <span class="k">if</span> <span class="n">new_col</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">ROW_MAJOR</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAJORITY_</span><span class="p">,</span> <span class="n">new_maj</span><span class="p">)</span>
        <span class="n">maj</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAJORITY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">maj</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">maj</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">ROW_MAJOR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">COLUMN_MAJOR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_MAJORITY</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">maj</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">COLUMN_MAJOR</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CDF.readonly"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.readonly">[docs]</a>    <span class="k">def</span> <span class="nf">readonly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ro</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets or check the readonly status of this CDF</span>

<span class="sd">        If the CDF has been changed since opening, setting readonly mode</span>
<span class="sd">        will have no effect.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        ro : Boolean</span>
<span class="sd">            True to set the CDF readonly, False to set it read/write,</span>
<span class="sd">            or leave out to check only.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : Boolean</span>
<span class="sd">            True if CDF is read-only, else False</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if bad mode is set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ro</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_READONLY_MODE_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">READONLYon</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ro</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_READONLY_MODE_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">READONLYoff</span><span class="p">)</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIRM_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_READONLY_MODE_</span><span class="p">,</span>
                   <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">READONLYon</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">READONLYoff</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_READONLY_MODE</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.checksum"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.checksum">[docs]</a>    <span class="k">def</span> <span class="nf">checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set or check the checksum status of this CDF. If checksums</span>
<span class="sd">        are enabled, the checksum will be verified every time the file</span>
<span class="sd">        is opened.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_val : boolean</span>
<span class="sd">            True to enable checksum, False to disable, or leave out</span>
<span class="sd">            to simply check.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : boolean</span>
<span class="sd">            True if the checksum is enabled or False if disabled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHECKSUM_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">MD5_CHECKSUM</span> <span class="k">if</span> <span class="n">new_val</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_CHECKSUM</span><span class="p">)</span>
        <span class="n">chk</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHECKSUM_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">chk</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">chk</span><span class="o">.</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">MD5_CHECKSUM</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">NO_CHECKSUM</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_CHECKSUM</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chk</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">MD5_CHECKSUM</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CDF.close"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes the CDF file</span>

<span class="sd">        Although called on object destruction (:meth:`~CDF.__del__`),</span>
<span class="sd">        to ensure all data are saved, the user should explicitly call</span>
<span class="sd">        :meth:`~CDF.close` or :meth:`~CDF.save`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CLOSE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opened</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="CDF.compress"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.compress">[docs]</a>    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set or check the compression of this CDF</span>

<span class="sd">        Sets compression on entire *file*, not per-variable.</span>

<span class="sd">        See section 2.6 of the CDF user&#39;s guide for more information on</span>
<span class="sd">        compression.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        comptype : ctypes.c_long</span>
<span class="sd">            type of compression to change to, see CDF C reference manual</span>
<span class="sd">            section 4.10. Constants for this parameter are in</span>
<span class="sd">            :mod:`~spacepy.pycdf.const`. If not specified, will not change</span>
<span class="sd">            compression.</span>
<span class="sd">        param : ctypes.c_long</span>
<span class="sd">            Compression parameter, see CDF CRM 4.10 and</span>
<span class="sd">            :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            If not specified, will choose reasonable default (5 for gzip;</span>
<span class="sd">            other types have only one possible parameter.)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            (comptype, param) currently in effect</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        :meth:`Var.compress`</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        Set file ``cdffile`` to gzip compression, compression level 9:</span>
<span class="sd">            &gt;&gt;&gt; cdffile.compress(pycdf.const.GZIP_COMPRESSION, 9)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.new"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.new">[docs]</a>    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recVary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dimVarys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compress_param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new zVariable in this CDF</span>

<span class="sd">        .. note::</span>
<span class="sd">            Either ``data`` or ``type`` must be specified. If type is not</span>
<span class="sd">            specified, it is guessed from ``data``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : str</span>
<span class="sd">            name of the new variable</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        data</span>
<span class="sd">            data to store in the new variable. If this has a an ``attrs``</span>
<span class="sd">            attribute (e.g., :class:`~spacepy.datamodel.dmarray`), it</span>
<span class="sd">            will be used to populate attributes of the new variable.</span>
<span class="sd">        type : ctypes.c_long</span>
<span class="sd">            CDF type of the variable, from :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            See section 2.5 of the CDF user&#39;s guide for more information on</span>
<span class="sd">            CDF data types.</span>
<span class="sd">        recVary : boolean</span>
<span class="sd">            record variance of the variable (default True)</span>
<span class="sd">        dimVarys : list of boolean</span>
<span class="sd">            dimension variance of each dimension, default True for all</span>
<span class="sd">            dimensions.</span>
<span class="sd">        dims : list of int</span>
<span class="sd">            size of each dimension of this variable, default zero-dimensional.</span>
<span class="sd">            Note this is the dimensionality as defined by CDF, i.e., for</span>
<span class="sd">            record-varying variables it excludes the leading record dimension.</span>
<span class="sd">            See :py:class:`Var`.</span>
<span class="sd">        n_elements : int</span>
<span class="sd">            number of elements, should be 1 except for CDF_CHAR,</span>
<span class="sd">            for which it&#39;s the length of the string.</span>
<span class="sd">        compress : ctypes.c_long</span>
<span class="sd">            Compression to apply to this variable, default None.</span>
<span class="sd">            See :py:meth:`Var.compress`.</span>
<span class="sd">        compress_param : ctypes.c_long</span>
<span class="sd">            Compression parameter if compression used; reasonable default</span>
<span class="sd">            is chosen. See :py:meth:`Var.compress`.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : :py:class:`Var`</span>
<span class="sd">            the newly-created zVariable</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        ValueError : if neither data nor sufficient typing information</span>
<span class="sd">                     is provided.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        Any given data may be representable by a range of CDF types; if</span>
<span class="sd">        the type is not specified, pycdf will guess which</span>
<span class="sd">        the CDF types which can represent this data. This breaks down to:</span>
<span class="sd">          #. If input data is a numpy array, match the type of that array</span>
<span class="sd">          #. Proper kind (numerical, string, time)</span>
<span class="sd">          #. Proper range (stores highest and lowest number provided)</span>
<span class="sd">          #. Sufficient resolution (EPOCH16 required if datetime has</span>
<span class="sd">             microseconds or below.)</span>

<span class="sd">        If more than one value satisfies the requirements, types are returned</span>
<span class="sd">        in preferred order:</span>
<span class="sd">          #. Type that matches precision of data first, then</span>
<span class="sd">          #. integer type before float type, then</span>
<span class="sd">          #. Smallest type first, then</span>
<span class="sd">          #. signed type first, then</span>
<span class="sd">          #. specifically-named (CDF_BYTE) vs. generically named (CDF_INT1)</span>
<span class="sd">        So for example, EPOCH_16 is preferred over EPOCH if ``data`` specifies</span>
<span class="sd">        below the millisecond level (rule 1), but otherwise EPOCH is preferred</span>
<span class="sd">        (rule 2).</span>

<span class="sd">        For floats, four-byte is preferred unless eight-byte is required:</span>
<span class="sd">          #. absolute values between 0 and 3e-39</span>
<span class="sd">          #. absolute values greater than 1.7e38</span>
<span class="sd">        This will switch to an eight-byte double in some cases where four bytes</span>
<span class="sd">        would be sufficient for IEEE 754 encoding, but where DEC formats would</span>
<span class="sd">        require eight.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use EPOCH16, INT8, or TIME_TT2000 &#39;</span>
                             <span class="s1">&#39;in backward-compatible CDF&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span> <span class="ow">and</span> \
                <span class="nb">type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;INT8 and TIME_TT2000 require CDF library 3.4.0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide either data or a CDF type.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">n_elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_elements</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">guess_dims</span><span class="p">,</span> <span class="n">guess_types</span><span class="p">,</span> <span class="n">guess_elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">types</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">recVary</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">guess_dims</span> <span class="o">==</span> <span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Record-varying data cannot be scalar. &#39;</span>
                            <span class="s1">&#39;Specify NRV with CDF.new() or put data in array.&#39;</span><span class="p">)</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">guess_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dims</span> <span class="o">=</span> <span class="n">guess_dims</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">type</span> <span class="o">=</span> <span class="n">guess_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward</span><span class="p">:</span>
                    <span class="nb">type</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span>
            <span class="k">if</span> <span class="n">n_elements</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_elements</span> <span class="o">=</span> <span class="n">guess_elements</span>
        <span class="k">if</span> <span class="n">dimVarys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimVarys</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span>
        <span class="n">recVary</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">recVary</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span>
        <span class="n">dimVarys</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">dimVary</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span>
                    <span class="k">for</span> <span class="n">dimVary</span> <span class="ow">in</span> <span class="n">dimVarys</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;64-bit integer support require CDF library 3.4.0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">backward</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data requires EPOCH16, INT8, or TIME_TT2000; &#39;</span>
                             <span class="s1">&#39;incompatible with backward-compatible CDF&#39;</span><span class="p">)</span>
        <span class="n">new_var</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">n_elements</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">recVary</span><span class="p">,</span> <span class="n">dimVarys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_var</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">compress</span><span class="p">,</span> <span class="n">compress_param</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_var</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;attrs&#39;</span><span class="p">):</span>
                <span class="n">new_var</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_var</span></div>

<div class="viewcode-block" id="CDF.raw_var"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.raw_var">[docs]</a>    <span class="k">def</span> <span class="nf">raw_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a &quot;raw&quot; :class:`Var` object.</span>

<span class="sd">        Normally a :class:`Var` will perform translation of values for</span>
<span class="sd">        certain types (to/from Unicode for CHAR variables on Py3k,</span>
<span class="sd">        and to/from datetime for all time types). A &quot;raw&quot; object</span>
<span class="sd">        does not perform this translation, on read or write.</span>

<span class="sd">        This does *not* affect the data on disk, and in fact it</span>
<span class="sd">        is possible to maintain multiple Python objects with access</span>
<span class="sd">        to the same zVariable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : str</span>
<span class="sd">            name or number of the zVariable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">v</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="CDF.save"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the CDF file but leaves it open.</span>

<span class="sd">        If closing the CDF, :meth:`close` is sufficient;</span>
<span class="sd">        there is no need to call</span>
<span class="sd">        :meth:`save` before :meth:`close`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Relies on an undocumented call of the CDF C library, which is</span>
<span class="sd">            also used in the Java interface.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning : if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SAVE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_</span><span class="p">)</span></div>

<div class="viewcode-block" id="CDF.version"><a class="viewcode-back" href="../../../../api/maser4py/maser.utils.cdf.cdf.html#maser.utils.cdf.cdf.CDF.version">[docs]</a>    <span class="k">def</span> <span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get version of library that created this CDF</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            version of CDF library, in form (version, release, increment)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_VERSION_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ver</span><span class="p">),</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_RELEASE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">rel</span><span class="p">),</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INCREMENT_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">inc</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ver</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">rel</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">inc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get attribute list</span>

<span class="sd">        Provide access to the CDF&#39;s attribute list without holding a</span>
<span class="sd">        strong reference, as the attribute list has a (strong)</span>
<span class="sd">        back-reference to its parent.</span>

<span class="sd">        Either deref a weak reference (to try and keep the object the same),</span>
<span class="sd">        or make a new AttrList instance and assign it to the weak reference</span>
<span class="sd">        for next time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">al</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">al</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">al</span> <span class="o">=</span> <span class="n">gAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">al</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">al</span>

    <span class="k">def</span> <span class="nf">_set_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign to the attribute list</span>

<span class="sd">        Clears all elements of the attribute list and copies from value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_get_attrs</span><span class="p">,</span> <span class="n">_set_attrs</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;Global attributes for this CDF in a dict-like format.</span>
<span class="sd">        See :class:`gAttrList` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Var</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A CDF variable.</span>

<span class="sd">    This object does not directly store the data from the CDF; rather,</span>
<span class="sd">    it provides access to the data in a format that much like a Python</span>
<span class="sd">    list or numpy :class:`~numpy.ndarray`.</span>
<span class="sd">    General list information is available in the python docs:</span>
<span class="sd">    `1 &lt;http://docs.python.org/tutorial/introduction.html#lists&gt;`_,</span>
<span class="sd">    `2 &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_,</span>
<span class="sd">    `3 &lt;http://docs.python.org/library/stdtypes.html#typesseq&gt;`_.</span>

<span class="sd">    The CDF user&#39;s guide, section 2.3, provides background on variables.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Not intended to be created directly; use methods of :class:`CDF` to</span>
<span class="sd">        gain access to a variable.</span>

<span class="sd">    A record-varying variable&#39;s data are viewed as a hypercube of dimensions</span>
<span class="sd">    n_dims+1 (the extra dimension is the record number). They are indexed in</span>
<span class="sd">    row-major fashion, i.e. the last index changes most frequently / is</span>
<span class="sd">    contiguous in memory. If the CDF is column-major, the data are</span>
<span class="sd">    transformed to row-major before return.</span>

<span class="sd">    Non record-varying variables are similar, but do not have the extra</span>
<span class="sd">    dimension of record number.</span>

<span class="sd">    Variables can be subscripted by a multidimensional index to return the</span>
<span class="sd">    data. Indices are in row-major order with the first dimension</span>
<span class="sd">    representing the record number. If the CDF is column major,</span>
<span class="sd">    the data are reordered to row major. Each dimension is specified</span>
<span class="sd">    by standard Python</span>
<span class="sd">    `slice &lt;http://docs.python.org/tutorial/introduction.html#strings&gt;`_</span>
<span class="sd">    notation, with dimensions separated by commas. The ellipsis fills in</span>
<span class="sd">    any missing dimensions with full slices. The returned data are</span>
<span class="sd">    lists; Python represents multidimensional arrays as nested lists.</span>
<span class="sd">    The innermost set of lists represents contiguous data.</span>

<span class="sd">    .. note::</span>
<span class="sd">        numpy &#39;fancy indexing&#39; is *not* supported.</span>

<span class="sd">    Degenerate dimensions are &#39;collapsed&#39;, i.e. no list of only one</span>
<span class="sd">    element will be returned if a single subscript is specified</span>
<span class="sd">    instead of a range. (To avoid this, specify a slice like 1:2,</span>
<span class="sd">    which starts with 1 and ends before 2).</span>

<span class="sd">    Two special cases:</span>

<span class="sd">      1. requesting a single-dimension slice for a</span>
<span class="sd">         record-varying variable will return all data for that</span>
<span class="sd">         record number (or those record numbers) for that variable.</span>
<span class="sd">      2. Requests for multi-dimensional variables may skip the record-number</span>
<span class="sd">         dimension and simply specify the slice on the array itself. In that</span>
<span class="sd">         case, the slice of the array will be returned for all records.</span>
<span class="sd">    In the event of ambiguity (e.g., single-dimension slice on a one-dimensional</span>
<span class="sd">    variable), case 1 takes priority.</span>
<span class="sd">    Otherwise, mismatch between the number of dimensions specified in</span>
<span class="sd">    the slice and the number of dimensions in the variable will cause</span>
<span class="sd">    an :exc:`~exceptions.IndexError` to be thrown.</span>

<span class="sd">    This all sounds very complicated but it is essentially attempting</span>
<span class="sd">    to do the &#39;right thing&#39; for a range of slices.</span>

<span class="sd">    An unusual case is scalar (zero-dimensional) non-record-varying variables.</span>
<span class="sd">    Clearly they cannot be subscripted normally. In this case, use the</span>
<span class="sd">    ``[...]`` syntax meaning &#39;access all data.&#39;:</span>

<span class="sd">    &gt;&gt;&gt; from spacepy import pycdf</span>
<span class="sd">    &gt;&gt;&gt; testcdf = pycdf.CDF(&#39;test.cdf&#39;, &#39;&#39;)</span>
<span class="sd">    &gt;&gt;&gt; variable = testcdf.new(&#39;variable&#39;, recVary=False,</span>
<span class="sd">    ...     type=pycdf.const.CDF_INT4)</span>
<span class="sd">    &gt;&gt;&gt; variable[...] = 10</span>
<span class="sd">    &gt;&gt;&gt; variable</span>
<span class="sd">    &lt;Var:</span>
<span class="sd">    CDF_INT4 [] NRV</span>
<span class="sd">    &gt;</span>
<span class="sd">    &gt;&gt;&gt; variable[...]</span>
<span class="sd">    10</span>

<span class="sd">    As a list type, variables are also `iterable</span>
<span class="sd">    &lt;http://docs.python.org/tutorial/classes.html#iterators&gt;`_; iterating</span>
<span class="sd">    over a variable returns a single complete record at a time.</span>

<span class="sd">    This is all clearer with examples. Consider a variable ``B_GSM``, with</span>
<span class="sd">    three elements per record (x, y, z components) and fifty records in</span>
<span class="sd">    the CDF. Then:</span>

<span class="sd">      1. ``B_GSM[0, 1]`` is the y component of the first record.</span>
<span class="sd">      2. ``B_GSM[10, :]`` is a three-element list, containing x, y, and z</span>
<span class="sd">         components of the 11th record. As a shortcut, if only one dimension</span>
<span class="sd">         is specified, it is assumed to be the record number, so this</span>
<span class="sd">         could also be written ``B_GSM[10]``.</span>
<span class="sd">      3. ``B_GSM[...]`` reads all data for ``B_GSM`` and returns it as a</span>
<span class="sd">         fifty-element list, each element itself being a three-element</span>
<span class="sd">         list of x, y, z components.</span>

<span class="sd">    Multidimensional example: consider fluxes stored as a function of</span>
<span class="sd">    pitch angle and energy. Such a variable may be called Flux and</span>
<span class="sd">    stored as a two-dimensional array, with the first dimension</span>
<span class="sd">    representing (say) ten energy steps and the second, eighteen</span>
<span class="sd">    pitch angle bins (ten degrees wide, centered from 5 to 175 degrees).</span>
<span class="sd">    Assume 100 records stored in the CDF (i.e. 100 different times).</span>

<span class="sd">      1. ``Flux[4]`` is a list of ten elements, one per energy step,</span>
<span class="sd">         each element being a list of 18 fluxes, one per pitch bin.</span>
<span class="sd">         All are taken from the fifth record in the CDF.</span>
<span class="sd">      2. ``Flux[4, :, 0:4]`` is the same record, all energies, but</span>
<span class="sd">         only the first four pitch bins (roughly, field-aligned).</span>
<span class="sd">      3. ``Flux[..., 0:4]`` is a 100-element list (one per record),</span>
<span class="sd">         each element being a ten-element list (one per energy step),</span>
<span class="sd">         each containing fluxes for the first four pitch bins.</span>
<span class="sd">    This slicing notation is very flexible and allows reading</span>
<span class="sd">    specifically the desired data from the CDF.</span>

<span class="sd">    All data are, on read, converted to appropriate Python data</span>
<span class="sd">    types; EPOCH, EPOCH16, and TIME_TT2000 types are converted to</span>
<span class="sd">    :class:`~datetime.datetime`. Data are returned in numpy arrays.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Although pycdf supports TIME_TT2000 variables, the Python</span>
<span class="sd">        :class:`~datetime.datetime` object does not support leap</span>
<span class="sd">        seconds. Thus, on read, any seconds past 59 are truncated</span>
<span class="sd">        to 59.999999 (59 seconds, 999 milliseconds, 999 microseconds).</span>

<span class="sd">    Potentially useful list methods and related functions:</span>
<span class="sd">      - `count</span>
<span class="sd">      &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_</span>
<span class="sd">      - `in &lt;http://docs.python.org/reference/expressions.html#in&gt;`_</span>
<span class="sd">      - `index</span>
<span class="sd">      &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_</span>
<span class="sd">      - `len &lt;http://docs.python.org/library/functions.html#len&gt;`_</span>
<span class="sd">      - `list comprehensions</span>
<span class="sd">        &lt;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&gt;`_</span>
<span class="sd">      - `sorted &lt;http://docs.python.org/library/functions.html#sorted&gt;`_</span>

<span class="sd">    The topic of array majority can be very confusing; good background material</span>
<span class="sd">    is available at `IDL Array Storage and Indexing</span>
<span class="sd">    &lt;http://www.dfanning.com/misc_tips/colrow_major.html&gt;`_. In brief,</span>
<span class="sd">    *regardless of the majority stored in the CDF*, pycdf will always present</span>
<span class="sd">    the data in the native Python majority, row-major order, also known as</span>
<span class="sd">    C order. This is the default order in `NumPy</span>
<span class="sd">    &lt;http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html</span>
<span class="sd">    #internal-memory-layout-of-an-ndarray&gt;`_.</span>
<span class="sd">    However, packages that render image data may expect it in column-major</span>
<span class="sd">    order. If the axes seem &#39;swapped&#39; this is likely the reason.</span>

<span class="sd">    The :attr:`~Var.attrs` Python attribute acts as a dictionary referencing</span>
<span class="sd">    zAttributes (do not confuse the two); all the dictionary methods above</span>
<span class="sd">    also work on the attribute dictionary. See :class:`zAttrList` for more on</span>
<span class="sd">    the dictionary of attributes.</span>

<span class="sd">    With writing, as with reading, every attempt has been made to match the</span>
<span class="sd">    behavior of Python lists. You can write one record, many records, or even</span>
<span class="sd">    certain elements of all records. There is one restriction: only the record</span>
<span class="sd">    dimension (i.e. dimension 0) can be resized by write, as all records</span>
<span class="sd">    in a variable must have the same dimensions. Similarly, only whole</span>
<span class="sd">    records can be deleted.</span>

<span class="sd">    For these examples, assume Flux has 100 records and dimensions [2, 3].</span>

<span class="sd">    Rewrite the first record without changing the rest:</span>

<span class="sd">    &gt;&gt;&gt; Flux[0] = [[1, 2, 3], [4, 5, 6]]</span>

<span class="sd">    Writes a new first record and delete all the rest:</span>

<span class="sd">    &gt;&gt;&gt; Flux[...] = [[1, 2, 3], [4, 5, 6]]</span>

<span class="sd">    Write a new record in the last position and add a new record after:</span>

<span class="sd">    &gt;&gt;&gt; Flux[99:] = [[[1, 2, 3], [4, 5, 6]],</span>
<span class="sd">    ...              [[11, 12, 13], [14, 15, 16]]]</span>

<span class="sd">    Insert two new records between the current number 5 and 6:</span>

<span class="sd">    &gt;&gt;&gt; Flux[5:6] = [[[1, 2, 3], [4, 5, 6]],  [[11, 12, 13],</span>
<span class="sd">    ...               [14, 15, 16]]]</span>

<span class="sd">    This operation can be quite slow, as it requires reading and</span>
<span class="sd">    rewriting the entire variable. (CDF does not directly support</span>
<span class="sd">    record insertion.)</span>

<span class="sd">    Change the first element of the first two records but leave other</span>
<span class="sd">    elements alone:</span>

<span class="sd">    &gt;&gt;&gt; Flux[0:2, 0, 0] = [1, 2]</span>

<span class="sd">    Remove the first record:</span>

<span class="sd">    &gt;&gt;&gt; del Flux[0]</span>

<span class="sd">    Removes record 5 (the sixth):</span>

<span class="sd">    &gt;&gt;&gt; del Flux[5]</span>

<span class="sd">    Due to the need to work around a bug in the CDF library, this operation</span>
<span class="sd">    can be quite slow.</span>

<span class="sd">    Delete *all data* from ``Flux``, but leave the variable definition intact:</span>

<span class="sd">    &gt;&gt;&gt; del Flux[...]</span>

<span class="sd">    .. note::</span>
<span class="sd">        Although this interface only directly supports zVariables, zMode is</span>
<span class="sd">        set on opening the CDF so rVars appear as zVars. See p.24 of the</span>
<span class="sd">        CDF user&#39;s guide; pyCDF uses zMode 2.</span>


<span class="sd">    .. autosummary::</span>

<span class="sd">        ~Var.attrs</span>
<span class="sd">        ~Var.compress</span>
<span class="sd">        ~Var.copy</span>
<span class="sd">        ~Var.dtype</span>
<span class="sd">        ~Var.dv</span>
<span class="sd">        ~Var.insert</span>
<span class="sd">        ~Var.name</span>
<span class="sd">        ~Var.rename</span>
<span class="sd">        ~Var.rv</span>
<span class="sd">        ~Var.shape</span>
<span class="sd">        ~Var.type</span>
<span class="sd">    .. attribute:: Var.attrs</span>

<span class="sd">       zAttributes for this zVariable in a dict-like format.</span>
<span class="sd">       See :class:`zAttrList` for details.</span>
<span class="sd">    .. automethod:: compress</span>
<span class="sd">    .. automethod:: copy</span>
<span class="sd">    .. autoattribute:: dtype</span>
<span class="sd">    .. automethod:: dv</span>
<span class="sd">    .. automethod:: insert</span>
<span class="sd">    .. automethod:: name</span>
<span class="sd">    .. automethod:: rename</span>
<span class="sd">    .. automethod:: rv</span>
<span class="sd">    .. autoattribute:: shape</span>
<span class="sd">    .. automethod:: type</span>
<span class="sd">..  @ivar cdf_file: the CDF file containing this variable</span>
<span class="sd">    @type cdf_file: :py:class:`CDF`</span>
<span class="sd">    @cvar attrs: Returns attributes for this zVariable (see L{zAttrList})</span>
<span class="sd">    @type attrs: L{_AttrListGetter}</span>
<span class="sd">    @ivar _name: name of this variable</span>
<span class="sd">    @type _name: string</span>
<span class="sd">    @ivar _type: CDF type of this variable</span>
<span class="sd">    @type _type: long</span>
<span class="sd">    @ivar _attrlistref: reference to the attribute list</span>
<span class="sd">                        (use L{attrs} instead)</span>
<span class="sd">    @type _attrlistref: weakref</span>
<span class="sd">    @ivar _raw: skip all data conversions (raw access), default False</span>
<span class="sd">    @ivar _raw: False</span>
<span class="sd">    @raise CDFError: if CDF library reports an error</span>
<span class="sd">    @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                       is set to error on warnings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdf_file</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create or locate a variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        cdf_file : :py:class:`pycdf.CDF`</span>
<span class="sd">            CDF file containing this variable</span>
<span class="sd">        var_name : string</span>
<span class="sd">            name of this variable</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        args</span>
<span class="sd">            additional arguments passed to :py:meth:`_create`. If none,</span>
<span class="sd">            opens an existing variable. If provided, creates a</span>
<span class="sd">            new one.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError</span>
<span class="sd">            if CDF library reports an error</span>

<span class="sd">        Warns</span>
<span class="sd">        =====</span>
<span class="sd">        CDFWarning</span>
<span class="sd">            if CDF library reports a warning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span> <span class="o">=</span> <span class="n">cdf_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a slice from the data array. Details under :py:class:`pycdf.Var`.</span>

<span class="sd">        @return: The data from this variable</span>
<span class="sd">        @rtype: list-of-lists of appropriate type.</span>
<span class="sd">        @raise IndexError: if L{key} is out of range, mismatches dimensions,</span>
<span class="sd">                           or simply unparseable.</span>
<span class="sd">        @raise CDFError: for errors from the CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hslice</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">create_array</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hslice</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_HYPERDATA_</span><span class="p">,</span>
                     <span class="n">result</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">hslice</span><span class="o">.</span><span class="n">convert_input_array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes a record (or set of records) from the CDF</span>

<span class="sd">        Only whole records can be deleted, so the del call must either specify</span>
<span class="sd">        only one dimension or it must specify all elements of the non-record</span>
<span class="sd">        dimensions. This is *not* a way to resize a variable!</span>

<span class="sd">        Deleting records from the middle of a variable may be very slow in</span>
<span class="sd">        some circumstances. To work around a bug in CDF library versions</span>
<span class="sd">        3.4.0 and before, all the data must be read in, the requested deletions</span>
<span class="sd">        done, and then all written back out.</span>

<span class="sd">        @param key: index or slice to delete</span>
<span class="sd">        @type key: int or slice</span>
<span class="sd">        @raise TypeError: if an attempt is made to delete from a non</span>
<span class="sd">                          record-varying variable, or to delete below</span>
<span class="sd">                          the record level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot delete records from non-record-varying &#39;</span>
                            <span class="s1">&#39;variable.&#39;</span><span class="p">)</span>
        <span class="n">hslice</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dims</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Can only delete entire records.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dimsize</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">()</span>
        <span class="n">dangerous_delete</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">_del_middle_rec_bug</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">interval</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">dimsize</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># delete from middle is dangerous if only have one index entry</span>
            <span class="n">entries</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_nINDEXENTRIES_</span><span class="p">,</span>
                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span>
            <span class="n">dangerous_delete</span> <span class="o">=</span> <span class="p">(</span><span class="n">entries</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dangerous_delete</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="n">interval</span><span class="p">,</span> <span class="n">interval</span><span class="p">),</span>
                <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">dimsize</span> <span class="o">-</span> <span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">first_rec</span> <span class="o">=</span> <span class="n">dimsize</span> <span class="o">-</span> <span class="n">count</span>
            <span class="n">last_rec</span> <span class="o">=</span> <span class="n">dimsize</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                     <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">first_rec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">last_rec</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first_rec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="n">last_rec</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                     <span class="n">first_rec</span><span class="p">,</span> <span class="n">last_rec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">()</span>
            <span class="c1"># delete from end to avoid renumbering of records</span>
            <span class="k">for</span> <span class="n">recno</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">interval</span><span class="p">,</span>
                               <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">interval</span><span class="p">):</span>
                <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                         <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">recno</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">recno</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Puts a slice into the data array. Details under :py:class:`pycdf.Var`.</span>

<span class="sd">        @param key: index or slice to store</span>
<span class="sd">        @type key: int or slice</span>
<span class="sd">        @param data: data to store</span>
<span class="sd">        @type data: numpy.array</span>
<span class="sd">        @raise IndexError: if L{key} is out of range, mismatches dimensions,</span>
<span class="sd">                           or simply unparseable. IndexError will</span>
<span class="sd">        @raise CDFError: for errors from the CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hslice</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">n_recs</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">hslice</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">cdf_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch16</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_np_type</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">datashape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datashape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Check data sizes</span>
        <span class="k">if</span> <span class="n">datashape</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">expected_dims</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;attempt to assign data of dimensions &#39;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">datashape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to slice of dimensions &#39;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">hslice</span><span class="o">.</span><span class="n">expected_dims</span><span class="p">()))</span>
            <span class="p">)</span>
        <span class="c1"># Flip majority and reversed dimensions, see convert_input_array</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">convert_output_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># Handle insertions and similar weirdness</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_recs</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_recs</span> <span class="o">&lt;</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># Specified slice ends before last record, so insert in middle</span>
            <span class="n">saved_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_recs</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hslice</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_HYPERDATA_</span><span class="p">,</span>
                     <span class="n">data</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n_recs</span><span class="p">:</span>
            <span class="n">first_rec</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last_rec</span> <span class="o">=</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">lib</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECORDS_</span><span class="p">,</span>
                     <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">first_rec</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">last_rec</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n_recs</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n_recs</span> <span class="o">&lt;</span> <span class="n">hslice</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># Put saved data in after inserted data</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">hslice</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">hslice</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">saved_data</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append multiple values to the end of this variable</span>

<span class="sd">        This is an efficiency function which overrides the base implementation</span>
<span class="sd">        in MutableSequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data :</span>
<span class="sd">            the data to append</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a *single* record before an index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            index before which to insert the new record</span>
<span class="sd">        data :</span>
<span class="sd">            the record to insert</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span> <span class="n">n_elements</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(),</span>
                <span class="n">recVary</span><span class="o">=</span><span class="n">const</span><span class="o">.</span><span class="n">VARY</span><span class="p">,</span> <span class="n">dimVarys</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new zVariable</span>

<span class="sd">        @param var_name: name of this variable</span>
<span class="sd">        @type var_name: string</span>
<span class="sd">        @param datatype: CDF data type</span>
<span class="sd">        @type datatype: ctypes.c_long</span>
<span class="sd">        @param n_elements: number of elements (should be 1 except for</span>
<span class="sd">                           CDF_CHAR variables).</span>
<span class="sd">        @type n_elements: long</span>
<span class="sd">        @param dims: size of each dimension for multi-dimensional variable,</span>
<span class="sd">                     or empty for a zero-dimensional</span>
<span class="sd">        @type dims: sequence of long</span>
<span class="sd">        @param recVary: record variance for this variable (VARY/NOVARY)</span>
<span class="sd">        @type recVary: long</span>
<span class="sd">        @param dimVarys: array of VARY or NOVARY, variance for each dimension</span>
<span class="sd">        @type dimVarys: sequence of long</span>
<span class="sd">        @return: new variable with this name</span>
<span class="sd">        @rtype: :py:class:`pycdf.Var`</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        @note: Not intended to be used directly; use L{CDF.new}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dim_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))(</span><span class="o">*</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">enc_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimVarys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim_vary_array</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)(</span><span class="n">const</span><span class="o">.</span><span class="n">VARY</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_vary_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))(</span><span class="o">*</span><span class="n">dimVarys</span><span class="p">)</span>
        <span class="n">varNum</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CREATE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_</span><span class="p">,</span> <span class="n">enc_name</span><span class="p">,</span> <span class="n">datatype</span><span class="p">,</span>
                            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">n_elements</span><span class="p">),</span>
                            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)),</span> <span class="n">dim_array</span><span class="p">,</span>
                            <span class="n">recVary</span><span class="p">,</span> <span class="n">dim_vary_array</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">varNum</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes this zVariable from the CDF</span>

<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NAME_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                            <span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets an existing zVariable</span>

<span class="sd">        @param var_name: name of this variable</span>
<span class="sd">        @type var_name: string</span>
<span class="sd">        @return: variable with this name</span>
<span class="sd">        @rtype: :py:class:`pycdf.Var`</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        @note: Not intended to be used directly; use L{CDF.__getitem__}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">str_classes</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">enc_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">enc_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="c1"># This call simply &#39;touches&#39; the CDF to cause an error if the name</span>
            <span class="c1"># isn&#39;t there</span>
            <span class="n">varNum</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
                <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span>
                <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMBER_</span><span class="p">,</span>
                <span class="n">enc_name</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">varNum</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_VAR_NAME_LEN256</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
                <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span>
                <span class="n">const</span><span class="o">.</span><span class="n">zVAR_</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">var_name</span><span class="p">),</span>
                <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span>
                <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NAME_</span><span class="p">,</span>
                <span class="n">name</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_num</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the zVar number for this variable</span>

<span class="sd">        @return: number of this zVar</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">varNum</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span>
            <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMBER_</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">varNum</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">varNum</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get number of records for this variable in this file</span>

<span class="sd">        @return: Number of records</span>
<span class="sd">        @rtype: long</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_MAXREC_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of the variable</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy,</span>
<span class="sd">        so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: info on this zVar</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;Var:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the variable</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create a :py:class:`pycdf.Var`.</span>

<span class="sd">        @return: info on this zVar, CDFTYPE [dimensions] NRV</span>
<span class="sd">                 (if not record-varying)</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
            <span class="n">chartypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">()</span>
            <span class="n">typestr</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">cdftype</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
                <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nelems</span><span class="p">())</span> <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="n">chartypes</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">rv</span><span class="p">:</span>
                <span class="n">sizestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sizestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">typestr</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">sizestr</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">rv</span> <span class="k">else</span> <span class="s1">&#39; NRV&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;zVar &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;zVar &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_n_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get number of dimensions for this variable</span>

<span class="sd">        @return: the number of dimensions</span>
<span class="sd">        @rtype: long</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_dims</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMDIMS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n_dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_dims</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">_dim_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the dimension sizes for this variable</span>

<span class="sd">        @return: sequence of sizes</span>
<span class="sd">        @rtype: sequence of long</span>
<span class="sd">        @note: This will always be in Python order (i.e. row major, last index</span>
<span class="sd">        iterates most quickly), *regardless* of the majority of the CDF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_DIMS</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMSIZES_</span><span class="p">,</span> <span class="n">sizes</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">sizes</span>

    <span class="k">def</span> <span class="nf">rv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_rv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets or sets whether this variable has record variance</span>

<span class="sd">        If the variance is unknown, True is assumed</span>
<span class="sd">        (this replicates the apparent behavior of the CDF library on</span>
<span class="sd">        variable creation).</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_rv : boolean</span>
<span class="sd">            True to change to record variance, False to change to NRV,</span>
<span class="sd">            unspecified to simply check variance.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : Boolean</span>
<span class="sd">            True if record varying, False if NRV</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_rv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECVARY_</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">new_rv</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span><span class="p">)</span>
        <span class="n">vary</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECVARY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">vary</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">vary</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">dv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dv</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets or sets dimension variance of each dimension of variable.</span>

<span class="sd">        If the variance is unknown, True is assumed</span>
<span class="sd">        (this replicates the apparent behavior of the</span>
<span class="sd">        CDF library on variable creation).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_dv : list of boolean</span>
<span class="sd">            Each element True to change that dimension to dimension</span>
<span class="sd">            variance, False to change to not dimension variance.</span>
<span class="sd">            (Unspecified to simply check variance.)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : list of boolean</span>
<span class="sd">            True if that dimension has variance, else false.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ndims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">new_dv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_dv</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify variance for &#39;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="n">ndims</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;dimensions.&#39;</span><span class="p">)</span>
            <span class="n">varies</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">ndims</span><span class="p">)(</span>
                <span class="o">*</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">VARY</span> <span class="k">if</span> <span class="n">dv</span> <span class="k">else</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span> <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="n">new_dv</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMVARYS_</span><span class="p">,</span>
                       <span class="n">varies</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndims</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">varies</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_MAX_DIMS</span><span class="p">)()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMVARYS_</span><span class="p">,</span> <span class="n">varies</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dv</span> <span class="o">!=</span> <span class="n">const</span><span class="o">.</span><span class="n">NOVARY</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="n">varies</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">ndims</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select this CDF and variable and call the CDF internal interface</span>

<span class="sd">        Adds call to select this CDF to L{args} and passes all parameters</span>
<span class="sd">        directly through to the CDFlib routine of the CDF library&#39;s C internal</span>
<span class="sd">        interface. Checks the return value with L{Library.check_status}.</span>

<span class="sd">        @param args: Passed directly to the CDF library interface. Useful</span>
<span class="sd">            constants are defined in the :py:mod:`pycdf.const` module of this</span>
<span class="sd">            package.</span>
<span class="sd">        @type args: various, see :py:mod:`ctypes`.</span>
<span class="sd">        @return: CDF status from the library</span>
<span class="sd">        @rtype: ctypes.c_long</span>
<span class="sd">        @note: Terminal NULL_ is automatically added to L{args}.</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NAME_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                                   <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_np_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the numpy type of this variable</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        CDFError : for library-reported error or failure to find numpy type</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : dtype</span>
<span class="sd">            numpy dtype that will hold value from this variable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span> <span class="ow">or</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nelems</span><span class="p">()))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">cdftype</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_DATA_TYPE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns or sets the CDF type of this variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_type : ctypes.c_long</span>
<span class="sd">            the new type from :mod:`~spacepy.pycdf.const`</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            CDF type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
            <span class="n">n_elements</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nelems</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DATASPEC_</span><span class="p">,</span>
                       <span class="n">new_type</span><span class="p">,</span> <span class="n">n_elements</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cdftype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DATATYPE_</span><span class="p">,</span>
                       <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">cdftype</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">cdftype</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span>

    <span class="k">def</span> <span class="nf">_nelems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of elements for each value in this variable</span>

<span class="sd">        This is the length of strings for CHAR and UCHAR,</span>
<span class="sd">        should be 1 otherwise.</span>
<span class="sd">        @return: length of strings</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nelems</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NUMELEMS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">nelems</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nelems</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of this variable</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : str</span>
<span class="sd">            variable&#39;s name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set or check the compression of this variable</span>

<span class="sd">        Compression may not be changeable on variables with data already</span>
<span class="sd">        written; even deleting the data may not permit the change.</span>

<span class="sd">        See section 2.6 of the CDF user&#39;s guide for more information on</span>
<span class="sd">        compression.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        comptype : ctypes.c_long</span>
<span class="sd">            type of compression to change to, see CDF C reference</span>
<span class="sd">            manual section 4.10. Constants for this parameter</span>
<span class="sd">            are in :mod:`~spacepy.pycdf.const`. If not specified, will not</span>
<span class="sd">            change compression.</span>
<span class="sd">        param : ctypes.c_long</span>
<span class="sd">            Compression parameter, see CDF CRM 4.10 and</span>
<span class="sd">            :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            If not specified, will choose reasonable default (5 for</span>
<span class="sd">            gzip; other types have only one possible parameter.)</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : tuple</span>
<span class="sd">            the (comptype, param) currently in effect</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comptype</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renames this variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_name : str</span>
<span class="sd">            the new name for this variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enc_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_VAR_NAME_LEN256</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_VAR_NAME</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_NAME_</span><span class="p">,</span> <span class="n">enc_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the numpy array-like shape of this variable.</span>

<span class="sd">        Returns a tuple; first element is number of records (RV variable</span>
<span class="sd">        only) And the rest provide the dimensionality of the variable.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Assigning to this attribute will not change the shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide the numpy dtype equivalent to the CDF type of this variable.</span>

<span class="sd">        Data from this variable will be returned in numpy arrays of this type.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_np_type</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get attribute list</span>

<span class="sd">        Provide access to the zVar&#39;s attribute list without holding a</span>
<span class="sd">        strong reference, as the attribute list has a (strong)</span>
<span class="sd">        back-reference to its parent.</span>

<span class="sd">        Either deref a weak reference (to try and keep the object the same),</span>
<span class="sd">        or make a new AttrList instance and assign it to the weak reference</span>
<span class="sd">        for next time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">al</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">al</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">al</span> <span class="o">=</span> <span class="n">zAttrList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrlistref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">al</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">al</span>

    <span class="k">def</span> <span class="nf">_set_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign to the attribute list</span>

<span class="sd">        Clears all elements of the attribute list and copies from value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span>
        <span class="n">_get_attrs</span><span class="p">,</span> <span class="n">_set_attrs</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;zAttributes for this zVariable in a dict-like format.</span>
<span class="sd">        See :class:`zAttrList` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_Hyperslice</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a CDF &#39;slice&#39; used for the hyper CDF functions</span>

<span class="sd">    For internal module use only.</span>

<span class="sd">    @ivar dims: number of dimensions to this slice, usually</span>
<span class="sd">                number of dimensions to the variable plus one</span>
<span class="sd">                for the record, which represents the 0th</span>
<span class="sd">                (least rapidly varying) dimension.</span>
<span class="sd">    @type dims: int</span>
<span class="sd">    @ivar dimsizes: size of each dimension (0th is number of records)</span>
<span class="sd">    @type dimsizes: list of int</span>
<span class="sd">    @ivar starts: index of the start value for each dimension</span>
<span class="sd">                  (&#39;dimension indices&#39; in CDF speak)</span>
<span class="sd">    @type starts: list of int</span>
<span class="sd">    @ivar counts: number of values to get from each dimension.</span>
<span class="sd">                  Final result will be the product of everything</span>
<span class="sd">                  in counts.</span>
<span class="sd">                  (&#39;dimension counts&#39; in CDF speak)</span>
<span class="sd">    @type counts: numpy.array</span>
<span class="sd">    @ivar intervals: interval between successive indices</span>
<span class="sd">                     to use for each dimension.</span>
<span class="sd">                     (&#39;dimension invervals&#39; in CDF speak)</span>
<span class="sd">    @type intervals: list of int</span>
<span class="sd">    @ivar degen: is this dimension degenerate, i.e. should be</span>
<span class="sd">                 removed in the returned dataset. A 3D array</span>
<span class="sd">                 with one dimension degenerate will be returned</span>
<span class="sd">                 as a 2D array (i.e. list-of-lists.)</span>
<span class="sd">    @type degen: numpy.array</span>
<span class="sd">    @ivar rev: should this dimension be returned in reverse order?</span>
<span class="sd">    @type rev: numpy.array</span>
<span class="sd">    @ivar column: is this slice in column-major mode (if false, row-major)</span>
<span class="sd">    @type column: boolean</span>
<span class="sd">    @ivar zvar: what CDF variable this object slices on</span>
<span class="sd">    @type zvar: :py:class:`pycdf.Var`</span>
<span class="sd">    @ivar expanded_key: fully-expanded version of the key passed to the</span>
<span class="sd">                        constructor (all dimensions filled in)</span>
<span class="sd">    @type expanded_key: tuple</span>
<span class="sd">    @note: All dimension-related variables are stored row-major</span>
<span class="sd">           (Python order)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zvar</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a Hyperslice</span>

<span class="sd">        @param zvar: zVariable that this slices</span>
<span class="sd">        @type zvar: :py:class:`pycdf.Var`</span>
<span class="sd">        @param key: Python multi-dimensional slice as passed to</span>
<span class="sd">                    __getitem__</span>
<span class="sd">        @type key: tuple of slice and/or int</span>
<span class="sd">        @raise IndexError: if slice is out of range, mismatches dimensions, or</span>
<span class="sd">                           otherwise unparsable.</span>
<span class="sd">        @raise ValueError: if slice has invalid values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span> <span class="o">=</span> <span class="n">zvar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">rv</span><span class="p">()</span>
        <span class="c1"># dim of records, + 1 record dim (NRV always is record 0)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">zvar</span><span class="o">.</span><span class="n">_n_dims</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">zvar</span><span class="p">)]</span> <span class="o">+</span> <span class="n">zvar</span><span class="o">.</span><span class="n">_dim_sizes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degen</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rev</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="c1"># key is:</span>
        <span class="c1"># 1. a single value (integer or slice object) if called 1D</span>
        <span class="c1"># 2. a tuple (of integers and/or slice objects) if called nD</span>
        <span class="c1"># 3. Each item is either a single value (degenerate dim)</span>
        <span class="c1">#   or a slice object.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">key</span>  <span class="c1"># NRV, so always get 0th record (degenerate)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_ellipsis</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span><span class="p">:</span>  <span class="c1"># special-cases for RV variables</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># get all data for this record(s)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_ellipsis</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># get same slice from each record</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expanded_key</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">):</span>  <span class="c1"># slice</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_range</span><span class="p">(</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">step</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Single degenerate value</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimsizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index out of range&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Slice does not match dimensions for zVar &#39;</span> <span class="o">+</span>
                             <span class="nb">str</span><span class="p">(</span><span class="n">zvar</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">zvar</span><span class="o">.</span><span class="n">cdf_file</span><span class="o">.</span><span class="n">col_major</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">expected_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate size of non-degenerate dimensions</span>

<span class="sd">        Figures out size, in each dimension, of expected input data</span>

<span class="sd">        @return: size of each dimension for this slice, excluding degenerate</span>
<span class="sd">        @rtype: list of int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands the record dimension of this slice to hold a set of data</span>

<span class="sd">        If the length of data (outermost dimension) is larger than the record</span>
<span class="sd">        count (counts[0]) for this slice, expand the slice to hold all the data.</span>
<span class="sd">        This requires that the record dimension of the slice not be degenerate,</span>
<span class="sd">        and also that it not have been completely specified when the hyperslice</span>
<span class="sd">        was created (i.e. record dimension either ellipsis or no specified</span>
<span class="sd">        stop.)</span>

<span class="sd">        Does *not* expand any other dimension, since that&#39;s Very Hard in CDF.</span>

<span class="sd">        @param data: the data which are intended to be stored in this slice</span>
<span class="sd">        @type data: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rec_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rv</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">str_classes</span><span class="p">,</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rec_slice</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># Truncate to fit data</span>
            <span class="k">if</span> <span class="n">rec_slice</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rec_slice</span><span class="o">.</span><span class="n">step</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># Expand to fit data</span>
            <span class="k">if</span> <span class="n">rec_slice</span><span class="o">.</span><span class="n">step</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a numpy array to hold the data from this slice</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : numpy.array</span>
<span class="sd">            array sized, typed, and dimensioned to hold data from</span>
<span class="sd">            this slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span>
        <span class="n">degen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
            <span class="n">degen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">degen</span><span class="p">)</span>
        <span class="c1"># TODO: Forcing C order for now, revert to using self.column later</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">[</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">_np_type</span><span class="p">(),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">convert_input_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a buffer of raw data from this slice</span>

<span class="sd">        EPOCH(16) variables always need to be converted.</span>
<span class="sd">        CHAR need converted to Unicode if py3k</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        buffer : numpy.array</span>
<span class="sd">            data as read from the CDF file</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : numpy.array</span>
<span class="sd">            converted data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flip_array</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>

        <span class="c1"># Convert to derived types</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="nb">str</span> <span class="o">!=</span> <span class="nb">bytes</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch_to_datetime</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch16_to_datetime</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">convert_output_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a buffer of data that will go into this slice</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        buffer : numpy.array</span>
<span class="sd">        data to go into the CDF file</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : numpy.array</span>
<span class="sd">        input with majority flipped and dimensions reversed to be</span>
<span class="sd">        suitable to pass directly to CDF library.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flip_array</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_flip_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operations for majority, etc. common between convert_input and _output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
        <span class="c1"># Flip majority if any non-degenerate dimensions exist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">):</span>
            <span class="c1"># Record-number dim degen, swap whole thing</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="c1"># Maintain last dimension</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                        <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
                        <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="c1"># Record-number dimension is not degenerate, so keep it first</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
                        <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="c1"># Reverse non-degenerate dimensions in rev</span>
        <span class="c1"># Remember that the degenerate indices are already gone!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rev</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">sliced</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">degen</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>  <span class="c1"># don&#39;t reverse last dim</span>
                <span class="n">sliced</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sliced</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Selects this hyperslice in the CDF</span>

<span class="sd">        Calls the CDF library to select the CDF, variable, records, and</span>
<span class="sd">        array elements corresponding to this slice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECNUMBER_</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECCOUNT_</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_RECINTERVAL_</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMINDICES_</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">dims</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                     <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMCOUNTS_</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">dims</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                     <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">zVAR_DIMINTERVALS_</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span> <span class="o">*</span> <span class="n">dims</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zvar</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">expand_ellipsis</span><span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">n_dims</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands any ellipses into correct number of full-size slices</span>

<span class="sd">        @param slices: tuple of slices, integers, or ellipse objects</span>
<span class="sd">        @type slices: tuple</span>
<span class="sd">        @param n_dims: number of dimensions this slice is over</span>
<span class="sd">        @type n_dims: int</span>
<span class="sd">        @return: L{slices} with ellipses replaced by appropriate number of</span>
<span class="sd">                 full-dimension slices</span>
<span class="sd">        @rtype: tuple</span>
<span class="sd">        @raise IndexError: if ellipses specified when already have enough</span>
<span class="sd">                           dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dims</span><span class="p">)])</span>
        <span class="c1"># Elements might be numpy arrays, so can&#39;t use in/index</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>  <span class="c1"># no ellipsis</span>
            <span class="k">return</span> <span class="n">slices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># multiples!</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Ellipses can only be used once per slice.&#39;</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># how many dims to expand ellipsis to</span>
        <span class="c1"># remember the ellipsis is in len(slices) and must be replaced!</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">n_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">extra</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;too many indices&#39;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">)</span> <span class="o">*</span> <span class="n">extra</span> <span class="o">+</span> <span class="n">slices</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_well_formed</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if input data is well-formed, regular array&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">object</span><span class="p">:</span>  <span class="c1"># this is probably going to be bad</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># at least it&#39;s not a list</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Data must be well-formed, regular array of number, &#39;</span>
                    <span class="s1">&#39;string, or datetime&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds the dimensions of a nested list-of-lists</span>

<span class="sd">        @param data: data of which dimensions are desired</span>
<span class="sd">        @type data: list (of lists)</span>
<span class="sd">        @return: dimensions of L{data}, in order outside-in</span>
<span class="sd">        @rtype: list of int</span>
<span class="sd">        @raise ValueError: if L{data} has irregular dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">check_well_formed</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find dimensions and valid types of a nested list-of-lists</span>

<span class="sd">        Any given data may be representable by a range of CDF types; infer</span>
<span class="sd">        the CDF types which can represent this data. This breaks down to:</span>
<span class="sd">          1. Proper kind (numerical, string, time)</span>
<span class="sd">          2. Proper range (stores highest and lowest number)</span>
<span class="sd">          3. Sufficient resolution (EPOCH16 required if datetime has</span>
<span class="sd">             microseconds or below.)</span>

<span class="sd">        If more than one value satisfies the requirements, types are returned</span>
<span class="sd">        in preferred order:</span>
<span class="sd">          1. Type that matches precision of data first, then</span>
<span class="sd">          2. integer type before float type, then</span>
<span class="sd">          3. Smallest type first, then</span>
<span class="sd">          4. signed type first, then</span>
<span class="sd">          5. specifically-named (CDF_BYTE) vs. generically named (CDF_INT1)</span>
<span class="sd">        So for example, EPOCH_16 is preferred over EPOCH if L{data} specifies</span>
<span class="sd">        below the millisecond level (rule 1), but otherwise EPOCH is preferred</span>
<span class="sd">        (rule 2).</span>

<span class="sd">        For floats, four-byte is preferred unless eight-byte is required:</span>
<span class="sd">          1. absolute values between 0 and 3e-39</span>
<span class="sd">          2. absolute values greater than 1.7e38</span>
<span class="sd">        This will switch to an eight-byte double in some cases where four bytes</span>
<span class="sd">        would be sufficient for IEEE 754 encoding, but where DEC formats would</span>
<span class="sd">        require eight.</span>

<span class="sd">        @param data: data for which dimensions and CDF types are desired</span>
<span class="sd">        @type data: list (of lists)</span>
<span class="sd">        @param backward: limit to pre-CDF3 types</span>
<span class="sd">        @type backward: bool</span>
<span class="sd">        @return: dimensions of L{data}, in order outside-in;</span>
<span class="sd">                 CDF types which can represent this data;</span>
<span class="sd">                 number of elements required (i.e. length of longest string)</span>
<span class="sd">        @rtype: 3-tuple of lists ([int], [ctypes.c_long], [int])</span>
<span class="sd">        @raise ValueError: if L{data} has irregular dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">check_well_formed</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">):</span>  <span class="c1"># it&#39;s a string</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="p">]</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>  <span class="c1"># UTF-8 uses 4 bytes per</span>
                <span class="n">elements</span> <span class="o">//=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;microsecond&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">((</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">%</span> <span class="mi">1000</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">flat</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="p">,</span>
                         <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">,</span>
                         <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">backward</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="p">)]</span>
                <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">data</span><span class="p">:</span>  <span class="c1"># numpy array came in, use its type</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span>
                <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">timetypes</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span><span class="p">:</span>  <span class="c1"># not a numpy array, or can&#39;t parse its type</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">):</span>  <span class="c1"># integer</span>
                <span class="n">minval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">maxval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">minval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="n">cutoffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">63</span><span class="p">,</span>
                               <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_BYTE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT1</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT1</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT2</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT2</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT4</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UINT4</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                             <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="n">cutoffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">8</span><span class="p">,</span>
                               <span class="mi">2</span> <span class="o">**</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">63</span><span class="p">,</span>
                               <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">1.7e38</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">,</span> <span class="mf">8e307</span><span class="p">]</span>
                <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">cutoffs</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">maxval</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">supports_int8</span> <span class="ow">or</span> <span class="n">backward</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span> <span class="ow">in</span> <span class="n">types</span>
                <span class="p">):</span>
                    <span class="k">del</span> <span class="n">types</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_INT8</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># float</span>
                <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="p">():</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.7e38</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3e-39</span><span class="p">):</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                                 <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">absolutes</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">absolutes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">absolutes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.7e38</span> <span class="ow">or</span>
                            <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">absolutes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3e-39</span>
                        <span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_FLOAT</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL4</span><span class="p">,</span>
                                 <span class="n">const</span><span class="o">.</span><span class="n">CDF_DOUBLE</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_REAL8</span><span class="p">]</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorders seq to switch array majority</span>

<span class="sd">        Used to take an array of subscripts between row</span>
<span class="sd">        and column majority. First element is not touched,</span>
<span class="sd">        being the record number.</span>

<span class="sd">        @param seq: a sequence of *subscripts*</span>
<span class="sd">        @type seq: sequence of integers</span>
<span class="sd">        @return: seq with all but element 0 reversed in order</span>
<span class="sd">        @rtype: sequence of integers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">numpy</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">seq</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a start/stop/step range to start/count/interval</span>

<span class="sd">        (i.e. changes from Python-style slice to CDF-style)</span>
<span class="sd">        @param start: index to start a slice at, may be none or negative</span>
<span class="sd">        @type start: int</span>
<span class="sd">        @param stop: index at end of slice (one-past, standard Python),</span>
<span class="sd">                     may be none or negative</span>
<span class="sd">        @type stop: int</span>
<span class="sd">        @param step: interval for stepping through stlice</span>
<span class="sd">        @type step: int</span>
<span class="sd">        @param size: size of list to slice</span>
<span class="sd">        @type size: int</span>
<span class="sd">        @return: (start, count, interval, rev) where:</span>
<span class="sd">                   1. start is the start index, normalized to be within</span>
<span class="sd">                      the size of the list and negatives handled</span>
<span class="sd">                   2. count is the number of records in the slice,</span>
<span class="sd">                      guaranteed to stop before the end</span>
<span class="sd">                   3. interval is the skip between records</span>
<span class="sd">                   4. rev indicates whether the sequence should be reversed</span>
<span class="sd">        @rtype: (int, int, int, boolean)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">step</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
            <span class="n">rev</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Attr</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An attribute, g or z, for a CDF</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This class should not be used directly, but only in its</span>
<span class="sd">        subclasses, :class:`gAttr` and :class:`zAttr`. The methods</span>
<span class="sd">        listed here are safe to use in the subclasses.</span>

<span class="sd">    Represents a CDF attribute, providing access to the Entries in a format</span>
<span class="sd">    that looks like a Python</span>
<span class="sd">    list. General list information is available in the python docs:</span>
<span class="sd">    `1 &lt;http://docs.python.org/tutorial/introduction.html#lists&gt;`_,</span>
<span class="sd">    `2 &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_,</span>
<span class="sd">    `3 &lt;http://docs.python.org/library/stdtypes.html#typesseq&gt;`_.</span>

<span class="sd">    An introduction to CDF attributes can be found in section 2.4 of</span>
<span class="sd">    the CDF user&#39;s guide.</span>

<span class="sd">    Each element of the list is a single Entry of the appropriate type.</span>
<span class="sd">    The index to the elements is the Entry number.</span>

<span class="sd">    Multi-dimensional slicing is *not* supported; an Entry with multiple</span>
<span class="sd">    elements will have all elements returned (and can thus be sliced itself).</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; first_three = attribute[5, 0:3] #will fail</span>
<span class="sd">        &gt;&gt;&gt; first_three = attribute[5][0:3] #first three elements of 5th Entry</span>

<span class="sd">    .. comment::</span>
<span class="sd">        @ivar _cdf_file: CDF file containing this attribute</span>
<span class="sd">        @type _cdf_file: :py:class:`pycdf.CDF`</span>
<span class="sd">        @ivar _name: Name of the attribute</span>
<span class="sd">        @type _name: bytes</span>

<span class="sd">    .. autosummary::</span>
<span class="sd">        ~Attr.has_entry</span>
<span class="sd">        ~Attr.max_idx</span>
<span class="sd">        ~Attr.new</span>
<span class="sd">        ~Attr.number</span>
<span class="sd">        ~Attr.rename</span>
<span class="sd">        ~Attr.type</span>
<span class="sd">    .. automethod:: has_entry</span>
<span class="sd">    .. automethod:: max_idx</span>
<span class="sd">    .. automethod:: new</span>
<span class="sd">    .. automethod:: number</span>
<span class="sd">    .. automethod:: rename</span>
<span class="sd">    .. automethod:: type</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdf_file</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this attribute</span>

<span class="sd">        @param cdf_file: CDF file containing this attribute</span>
<span class="sd">        @type cdf_file: :py:class:`pycdf.CDF`</span>
<span class="sd">        @param attr_name: Name of this attribute</span>
<span class="sd">        @type attr_name: str</span>
<span class="sd">        @param create: True to create attribute, False to look up existing.</span>
<span class="sd">        @type create: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span> <span class="o">=</span> <span class="n">cdf_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">str_classes</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">attr_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">attr_name</span>
            <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
                <span class="n">attrno</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CREATE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SCOPE</span><span class="p">,</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">attrno</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIRM_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_EXISTENCE_</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_ATTR_NAME_LEN256</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">,</span>
                                 <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">attr_name</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NAME_</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a slice of Entries.</span>

<span class="sd">        Because Attributes may be sparse, a multi-element slice will return</span>
<span class="sd">        None for those elements which do not have associated Entries.</span>

<span class="sd">        @param key: index or range of Entry number to return</span>
<span class="sd">        @type key: slice or int</span>
<span class="sd">        @return: a list of entries, appropriate type.</span>
<span class="sd">        @raise IndexError: if L{key} is an int and that Entry number does not</span>
<span class="sd">                           exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a slice of Entries.</span>

<span class="sd">        @param key: index or range of Entry numbers to set</span>
<span class="sd">        @type key: slice or int</span>
<span class="sd">        @param data: the data to set these entries to. Normally each entry</span>
<span class="sd">        should be a sequence; if a scalar is provided, it is treated as a</span>
<span class="sd">        single-element list.</span>
<span class="sd">        @type data: scalar or list</span>
<span class="sd">        @raise ValueError: if size of {data} does not match size of L{key}</span>
<span class="sd">        @note: Attributes do not &#39;grow&#39; or &#39;shrink&#39; as entries are added</span>
<span class="sd">               or removed. Indexes of entries never change and there is no</span>
<span class="sd">               way to &#39;insert&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">):</span>
            <span class="c1"># Single value, promote everything a dimension</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Iterating forward, extend slice to match data</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">)):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># get, and check, types and sizes for all data</span>
        <span class="c1"># checks first so don&#39;t have error after changing half the Entries</span>
        <span class="n">data_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">typelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">data_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">data_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">datum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">datum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">typelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">types</span><span class="p">(</span>
                <span class="n">datum</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">backward</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot find a matching CDF type.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Entries must be scalar or 1D.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">str_classes</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Entry strings must be scalar.&#39;</span><span class="p">)</span>
            <span class="n">entrytypes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="n">entrytype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">entrytype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="n">entrytypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">entrytype</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">entrytypes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                        <span class="n">entrytype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">entrytype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                            <span class="n">entrytypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entrytype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">entrytypes</span><span class="p">:</span>
                <span class="c1"># Of those types in entrytypes, find the one which is earliest</span>
                <span class="c1"># in types, i.e. the preferred type</span>
                <span class="n">entry_type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span>
                    <span class="nb">min</span><span class="p">([</span><span class="n">types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">entrytype</span><span class="p">)</span> <span class="k">for</span> <span class="n">entrytype</span> <span class="ow">in</span> <span class="n">entrytypes</span><span class="p">])</span>
                <span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_</span><span class="p">:</span>
                <span class="n">vartype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">vartype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="n">entry_type</span> <span class="o">=</span> <span class="n">vartype</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">entry_type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">entry_type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">entry_type</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot find a matching numpy type.&#39;</span><span class="p">)</span>
            <span class="n">typelist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dims</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">,</span> <span class="n">elements</span><span class="p">))</span>

        <span class="n">data_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">data_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">data_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="n">datum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">typelist</span><span class="p">[</span><span class="n">data_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">datum</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete a slice of Entries.</span>

<span class="sd">        @param key: index or range of Entry numbers to delete</span>
<span class="sd">        @type key: slice or int</span>
<span class="sd">        @note: Attributes do not &#39;grow&#39; or &#39;shrink&#39; as entries are added</span>
<span class="sd">               or removed. Indexes of entries never change and there is no</span>
<span class="sd">               way to &#39;insert&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over all entries in this Attribute</span>

<span class="sd">        Returns data from one entry at a time until reaches the end.</span>
<span class="sd">        @note: Returned in entry-number order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over all entries in this Attribute</span>

<span class="sd">        Returns data from one entry at a time, starting at end and going</span>
<span class="sd">        to beginning.</span>
<span class="sd">        @note: Returned in entry-number order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_entry</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">current</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">current</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of Entries for this Attr. NOT same as max Entry number.</span>

<span class="sd">        @return: Number of Entries</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_NUMENTRIES_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of an attribute</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy of the</span>
<span class="sd">        attribtute, so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: all the data in this attribute</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the attribute</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create an L{Attr}.</span>

<span class="sd">        @return: all the data in this attribute</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute &quot;</span><span class="si">{0}</span><span class="s1">&quot; in closed CDF </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert an entry at a particular number</span>

<span class="sd">        Entry numbers do not change on insertion/deletion, so this function</span>
<span class="sd">        cannot be implemented.</span>
<span class="sd">        @raise NotImplementedError: always</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select this CDF and Attr and call the CDF internal interface</span>

<span class="sd">        @param args: Passed directly to the CDF library interface.</span>
<span class="sd">        @type args: various, see :py:mod:`ctypes`.</span>
<span class="sd">        @return: CDF status from the library</span>
<span class="sd">        @rtype: ctypes.c_long</span>
<span class="sd">        @note: Terminal NULL_ is automatically added to L{args}.</span>
<span class="sd">        @raise CDFError: if CDF library reports an error</span>
<span class="sd">        @raise CDFWarning: if CDF library reports a warning and interpreter</span>
<span class="sd">                           is set to error on warnings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NAME_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_entry_len</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of elements in an Entry</span>

<span class="sd">        @param number: number of Entry</span>
<span class="sd">        @type number: int</span>
<span class="sd">        @return: number of elements</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
            <span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span>
            <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_NUMELEMS_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find or change the CDF type of a particular Entry number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        number : int</span>
<span class="sd">            number of Entry to check or change</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        new_type</span>
<span class="sd">            type to change this Entry to, from :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            Omit to only check type.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            CDF variable type, see :mod:`~spacepy.pycdf.const`</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        If changing types, old and new must be equivalent, see CDF</span>
<span class="sd">        User&#39;s Guide section 2.5.5 pg. 57</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_type</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">new_type</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entry_len</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span>
                       <span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATASPEC_</span><span class="p">,</span> <span class="n">new_type</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATATYPE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">cdftype</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cdftype</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">has_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if this attribute has a particular Entry number</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        number : int</span>
<span class="sd">            number of Entry to check or change</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : bool</span>
<span class="sd">            True if ``number`` is a valid entry number; False if not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CONFIRM_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_EXISTENCE_</span><span class="p">,</span>
                            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
                            <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ENTRY</span>

    <span class="k">def</span> <span class="nf">max_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum index of Entries for this Attr</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            maximum Entry number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_MAXENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new Entry in this Attribute</span>

<span class="sd">        .. note:: If ``number`` is provide and an Entry with that number</span>
<span class="sd">                  already exists, it will be overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        data</span>
<span class="sd">            data to put in the Entry</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        type : int</span>
<span class="sd">            type of the new Entry, from :mod:`~spacepy.pycdf.const`</span>
<span class="sd">            (otherwise guessed from ``data``)</span>
<span class="sd">        number : int</span>
<span class="sd">            Entry number to write, default is lowest available number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
                <span class="n">number</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="o">=</span> <span class="n">_Hyperslice</span><span class="o">.</span><span class="n">types</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">backward</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">backward</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_</span><span class="p">:</span> <span class="c1">#Try to match variable type</span>
                <span class="n">vartype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">[</span><span class="n">number</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">vartype</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
                    <span class="nb">type</span> <span class="o">=</span> <span class="n">vartype</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">):</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_entry</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the attribute number for this attribute</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            attribute number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NUMBER_</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">no</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">no</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">global_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine scope of this attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : bool</span>
<span class="sd">            True if global (i.e. gAttr), False if zAttr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_SCOPE_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">scope</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">scope</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">GLOBAL_SCOPE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">scope</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">VARIABLE_SCOPE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_SCOPE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rename this attribute</span>

<span class="sd">        Renaming a zAttribute renames it for *all* zVariables in this CDF!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        new_name : str</span>
<span class="sd">             the new name of the attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">enc_name</span> <span class="o">=</span> <span class="n">new_name</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enc_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_ATTR_NAME_LEN256</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_ATTR_NAME</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NAME_</span><span class="p">,</span> <span class="n">enc_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">enc_name</span>

    <span class="k">def</span> <span class="nf">_get_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read an Entry associated with this L{Attr}</span>

<span class="sd">        @param number: number of Entry to return</span>
<span class="sd">        @type number: int</span>
<span class="sd">        @return: data from entry numbered L{number}</span>
<span class="sd">        @rtype: list or str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;list index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; out of range.&#39;</span><span class="p">)</span>
        <span class="c1">#Make a big enough buffer</span>
        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entry_len</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="n">cdftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="n">buff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((),</span> <span class="s1">&#39;S</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_DATA_TYPE</span><span class="p">)</span>
            <span class="n">buff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">length</span><span class="p">,),</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">cdftype</span><span class="p">],</span>
                               <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATA_</span><span class="p">,</span>
                   <span class="n">buff</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>

        <span class="c1">#decode</span>
        <span class="k">if</span> <span class="n">cdftype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">str</span> <span class="o">==</span> <span class="nb">bytes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span> <span class="c1">#Py2k, leave as bytes</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#Py3k, make unicode</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch_to_datetime</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_epoch16_to_datetime</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">cdftype</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_tt2000_to_datetime</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_write_entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cdf_type</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write an Entry to this Attr.</span>

<span class="sd">        @param number: number of Entry to write</span>
<span class="sd">        @type number: int</span>
<span class="sd">        @param data: data to write</span>
<span class="sd">        @param cdf_type: the CDF type to write, from :py:mod:`pycdf.const`</span>
<span class="sd">        @param dims: dimensions of L{data}</span>
<span class="sd">        @type dims: list</span>
<span class="sd">        @param elements: number of elements in L{data}, 1 unless it is a string</span>
<span class="sd">        @type elements: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n_write</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_write</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cdf_type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">CDF_CHAR</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_UCHAR</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">elements</span><span class="p">)))</span>
            <span class="n">n_write</span> <span class="o">=</span> <span class="n">elements</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH16</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch16</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_EPOCH</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_epoch</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_TIME_TT2000</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">v_datetime_to_tt2000</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cdf_type</span> <span class="ow">in</span> <span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">numpytypedict</span><span class="p">[</span><span class="n">cdf_type</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CDFError</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">BAD_DATA_TYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">SELECT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">number</span><span class="p">),</span>
                   <span class="n">const</span><span class="o">.</span><span class="n">PUT_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATA_</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">cdf_type</span><span class="p">),</span>
                   <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="n">n_write</span><span class="p">),</span>
                   <span class="n">data</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete this Attribute</span>

<span class="sd">        Also deletes all Entries associated with it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">DELETE_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">zAttr</span><span class="p">(</span><span class="n">Attr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;zAttribute for zVariables within a CDF.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Because zAttributes are shared across all variables in a CDF,</span>
<span class="sd">        directly manipulating them may have unexpected consequences.</span>
<span class="sd">        It is safest to operate on zEntries via :class:`zAttrList`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        When accessing a zAttr, pyCDF exposes only the zEntry corresponding</span>
<span class="sd">        to the associated zVariable.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`Attr`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this attribute&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATA_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_DATA_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SCOPE</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">VARIABLE_SCOPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_EXISTENCE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_EXISTENCE_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_NUMENTRIES_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NUMzENTRIES_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_MAXENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_MAXzENTRY_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_NUMELEMS_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_NUMELEMS_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATATYPE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_DATATYPE_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATASPEC_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">zENTRY_DATASPEC_</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">zAttr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">gAttr</span><span class="p">(</span><span class="n">Attr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Global Attribute for a CDF</span>

<span class="sd">    Represents a CDF attribute, providing access to the gEntries in a format</span>
<span class="sd">    that looks like a Python</span>
<span class="sd">    list. General list information is available in the python docs:</span>
<span class="sd">    `1 &lt;http://docs.python.org/tutorial/introduction.html#lists&gt;`_,</span>
<span class="sd">    `2 &lt;http://docs.python.org/tutorial/datastructures.html#more-on-lists&gt;`_,</span>
<span class="sd">    `3 &lt;http://docs.python.org/library/stdtypes.html#typesseq&gt;`_.</span>

<span class="sd">    Normally accessed by providing a key to a :class:`gAttrList`:</span>
<span class="sd">        &gt;&gt;&gt; attribute = cdffile.attrs[&#39;attribute_name&#39;]</span>
<span class="sd">        &gt;&gt;&gt; first_gentry = attribute[0]</span>

<span class="sd">    Each element of the list is a single gEntry of the appropriate type.</span>
<span class="sd">    The index to the elements is the gEntry number.</span>

<span class="sd">    A gEntry may be either a single string or a 1D array of numerical type.</span>
<span class="sd">    Entries of numerical type (everything but CDF_CHAR and CDF_UCHAR)</span>
<span class="sd">    with a single element are returned as scalars; multiple-element entries</span>
<span class="sd">    are returned as a list. No provision is made for accessing below</span>
<span class="sd">    the entry level; the whole list is returned at once (but Python&#39;s</span>
<span class="sd">    slicing syntax can be used to extract individual items from that list.)</span>

<span class="sd">    Multi-dimensional slicing is *not* supported; an entry with multiple</span>
<span class="sd">    elements will have all elements returned (and can thus be sliced itself).</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; first_three = attribute[5, 0:3] #will fail</span>
<span class="sd">        &gt;&gt;&gt; first_three = attribute[5][0:3] #first three elements of 5th Entry</span>

<span class="sd">    gEntries are *not* necessarily contiguous; a gAttribute may have an</span>
<span class="sd">    entry 0 and entry 2 without an entry 1. :meth:`~Attr.len` will return the</span>
<span class="sd">    *number* of gEntries; use :meth:`~Attr.max_idx` to find the highest defined</span>
<span class="sd">    gEntry number and :meth:`~Attr.has_entry` to determine if a particular</span>
<span class="sd">    gEntry number exists. Iterating over all entries is also supported::</span>
<span class="sd">        &gt;&gt;&gt; entrylist = [entry for entry in attribute]</span>

<span class="sd">    Deleting gEntries will leave a &quot;hole&quot;:</span>
<span class="sd">        &gt;&gt;&gt; attribute[0:3] = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; del attribute[1]</span>
<span class="sd">        &gt;&gt;&gt; attribute.has_entry(1)</span>
<span class="sd">            False</span>
<span class="sd">        &gt;&gt;&gt; attribute.has_entry(2)</span>
<span class="sd">            True</span>
<span class="sd">        &gt;&gt;&gt; print attribute[0:3]</span>
<span class="sd">            [1, None, 3]</span>

<span class="sd">    Multi-element slices over nonexistent gEntries will return ``None`` where</span>
<span class="sd">    no entry exists. Single-element indices for nonexistent gEntries will</span>
<span class="sd">    raise ``IndexError``. Assigning ``None`` to a gEntry will delete it.</span>

<span class="sd">    When assigning to a gEntry, the type is chosen to match the data;</span>
<span class="sd">    subject to that constraint, it will try to match</span>
<span class="sd">    (in order):</span>
<span class="sd">      1. existing gEntry of the same number in this gAttribute</span>
<span class="sd">      2. other gEntries in this gAttribute</span>
<span class="sd">      3. data-matching constraints described in :meth:`CDF.new`.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`Attr`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize this attribute&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATA_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_DATA_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SCOPE</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">GLOBAL_SCOPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_EXISTENCE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_EXISTENCE_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_NUMENTRIES_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_NUMgENTRIES_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ATTR_MAXENTRY_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">ATTR_MAXgENTRY_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_NUMELEMS_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_NUMELEMS_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATATYPE_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_DATATYPE_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ENTRY_DATASPEC_</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gENTRY_DATASPEC_</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">gAttr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AttrList</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object representing a list of attributes.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This class should not be used directly, but only via its</span>
<span class="sd">        subclasses, :class:`gAttrList` and :class:`zAttrList`.</span>
<span class="sd">        Methods listed here are safe to use from the subclasses.</span>

<span class="sd">    .. autosummary::</span>

<span class="sd">        ~AttrList.clone</span>
<span class="sd">        ~AttrList.copy</span>
<span class="sd">        ~AttrList.from_dict</span>
<span class="sd">        ~AttrList.new</span>
<span class="sd">        ~AttrList.rename</span>

<span class="sd">    .. automethod:: clone</span>
<span class="sd">    .. automethod:: copy</span>
<span class="sd">    .. automethod:: from_dict</span>
<span class="sd">    .. automethod:: new</span>
<span class="sd">    .. automethod:: rename</span>

<span class="sd">    .. comment::</span>
<span class="sd">        @ivar _cdf_file: CDF these attributes are in</span>
<span class="sd">        @type _cdf_file: :py:class:`pycdf.CDF`</span>
<span class="sd">        @ivar special_entry: callable which returns a &quot;special&quot;</span>
<span class="sd">            entry number, used to limit results</span>
<span class="sd">            for zAttrs to those which match the zVar</span>
<span class="sd">        @type special_entry: callable</span>
<span class="sd">        @cvar AttrType: type of attribute in this list, L{zAttr} or L{gAttr}</span>
<span class="sd">        @type AttrType: type</span>
<span class="sd">        @cvar attr_name: name of attribute type, &#39;zAttribute&#39; or &#39;gAttribute&#39;</span>
<span class="sd">        @type attr_name: str</span>
<span class="sd">        @cvar global_scope: is this list scoped global (True) or variable (False)</span>
<span class="sd">        @type global_scope: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cdf_file</span><span class="p">,</span> <span class="n">special_entry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the attribute collection</span>

<span class="sd">        @param cdf_file: CDF these attributes are in</span>
<span class="sd">        @type cdf_file: :py:class:`pycdf.CDF`</span>
<span class="sd">        @param special_entry: callable which returns a &quot;special&quot; entry number,</span>
<span class="sd">        used to limit results for zAttrs to those which match the zVar</span>
<span class="sd">        @type special_entry: callable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span> <span class="o">=</span> <span class="n">cdf_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span> <span class="o">=</span> <span class="n">special_entry</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find an Attribute by name</span>

<span class="sd">        @param name: name of the Attribute to return</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @return: attribute named L{name}</span>
<span class="sd">        @rtype: L{Attr}</span>
<span class="sd">        @raise KeyError: if there is no attribute named L{name}</span>
<span class="sd">        @raise CDFError: other errors in CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attrib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFError</span><span class="p">:</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ATTR</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">if</span> <span class="n">attrib</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: no &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span> <span class="o">+</span> <span class="s1">&#39; by that name.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">attrib</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Attribute or change its entries</span>

<span class="sd">        @param name: name of Attribute to change</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param data: Entries to populate this Attribute with.</span>
<span class="sd">                     Any existing Entries will be deleted!</span>
<span class="sd">                     Another C{Attr} may be specified, in which</span>
<span class="sd">                     case all its entries are copied.</span>
<span class="sd">        @type data: scalar, list, or L{Attr}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">AttrList</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">entryno</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">entryno</span><span class="p">):</span>
                    <span class="n">attr</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">entryno</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">entryno</span><span class="p">),</span> <span class="n">entryno</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str_classes</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">junk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="n">attr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">del</span> <span class="n">attr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):]</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an Attribute (and all its entries)</span>

<span class="sd">        @param name: name of Attribute to delete</span>
<span class="sd">        @type name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFError</span><span class="p">:</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ATTR</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: not &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterates over all Attr in this CDF or variable</span>

<span class="sd">        Returns name of one L{Attr} at a time until reaches the end.</span>
<span class="sd">        @note: Returned in number order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMATTRS_</span><span class="p">,</span>
                             <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">candidate</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
                        <span class="n">candidate</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="nb">str</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="k">yield</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">()</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns representation of attribute list</span>

<span class="sd">        Cannot return anything that can be eval&#39;d to create a copy of the</span>
<span class="sd">        list, so just wrap the informal representation in angle brackets.</span>
<span class="sd">        @return: all the data in this list of attributes</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;:</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string representation of the attribute list</span>

<span class="sd">        This is an &#39;informal&#39; representation in that it cannot be evaluated</span>
<span class="sd">        directly to create an L{AttrList}.</span>

<span class="sd">        @return: all the data in this list of attributes</span>
<span class="sd">        @rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_opened</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="p">(</span>
                <span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">max_idx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Attr</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span>
                <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="n">lib</span><span class="o">.</span><span class="n">cdftypenames</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute list in closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;Attribute list in closed CDF </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clones another attribute list, or one attribute from it, into this</span>
<span class="sd">        list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        master : AttrList</span>
<span class="sd">            the attribute list to copy from. This can be any dict-like object.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        name : str (optional)</span>
<span class="sd">            name of attribute to clone (default: clone entire list)</span>
<span class="sd">        new_name : str (optional)</span>
<span class="sd">            name of the new attribute, default ``name``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clone_list</span><span class="p">(</span><span class="n">master</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clone_attr</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a copy of this attribute list</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : dict</span>
<span class="sd">            copy of the entries for all attributes in this list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">[:]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Attr</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Attr in this AttrList</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        name : str</span>
<span class="sd">            name of the new Attribute</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ================</span>
<span class="sd">        data</span>
<span class="sd">            data to put into the first entry in the new Attribute</span>
<span class="sd">        type</span>
<span class="sd">            CDF type of the first entry from :mod:`~spacepy.pycdf.const`.</span>
<span class="sd">            Only used if data are specified.</span>

<span class="sd">        Raises</span>
<span class="sd">        ======</span>
<span class="sd">        KeyError : if the name already exists in this list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; already exists.&#39;</span><span class="p">)</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attr</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attr</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_entry</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename an attribute in this list</span>

<span class="sd">        Renaming a zAttribute renames it for *all* zVariables in this CDF!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        old_name : str</span>
<span class="sd">            the current name of the attribute</span>
<span class="sd">        new_name : str</span>
<span class="sd">            the new name of the attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">AttrList</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill this list of attributes from a dictionary</span>

<span class="sd">        .. deprecated:: 0.1.5</span>
<span class="sd">           Use :meth:`~spacepy.pycdf.AttrList.clone` instead; it supports</span>
<span class="sd">           cloning from dictionaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        in_dict : dict</span>
<span class="sd">            Attribute list is populated entirely from this dictionary;</span>
<span class="sd">            all existing attributes are deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;from_dict is deprecated and will be removed. Use clone.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">in_dict</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_clone_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones a single attribute from one in this list or another</span>

<span class="sd">        Copies data and types from the master attribute to the new one</span>

<span class="sd">        @param master: attribute list to copy attribute from</span>
<span class="sd">        @type master: L{AttrList}</span>
<span class="sd">        @param name: name of attribute to copy</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param new_name: name of the new attribute, default L{name}</span>
<span class="sd">        @type new_name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">master</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_clone_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones this attribute list from another</span>

<span class="sd">        @param master: the attribute list to copy from</span>
<span class="sd">        @type master: L{AttrList}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">master</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clone_attr</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#Can&#39;t iterate over a list we&#39;re changing</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">master</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_or_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve L{Attr} or create it if it doesn&#39;t exist</span>

<span class="sd">        @param name: name of the attribute to look up or create</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @return: attribute with this name</span>
<span class="sd">        @rtype: L{Attr}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CDFError</span><span class="p">:</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">const</span><span class="o">.</span><span class="n">NO_SUCH_ATTR</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">AttrType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">global_scope</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: not &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">attr</span>


<span class="k">class</span> <span class="nc">gAttrList</span><span class="p">(</span><span class="n">AttrList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object representing *all* the gAttributes in a CDF.</span>

<span class="sd">    Normally accessed as an attribute of an open :py:class:`CDF`:</span>
<span class="sd">        &gt;&gt;&gt; global_attribs = cdffile.attrs</span>

<span class="sd">    Appears as a dictionary: keys are attribute names; each value is an</span>
<span class="sd">    attribute represented by a :py:class:`gAttr` object. To access the global</span>
<span class="sd">    attribute TEXT:</span>
<span class="sd">        &gt;&gt;&gt; text_attr = cdffile.attrs[&#39;TEXT&#39;]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`AttrList`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">AttrType</span> <span class="o">=</span> <span class="n">gAttr</span>
    <span class="n">attr_name</span> <span class="o">=</span> <span class="s1">&#39;gAttribute&#39;</span>
    <span class="n">global_scope</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of gAttributes in this CDF</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>
<span class="sd">        out : int</span>
<span class="sd">            number of gAttributes in the CDF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMgATTRS_</span><span class="p">,</span>
                             <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span>


<span class="k">class</span> <span class="nc">zAttrList</span><span class="p">(</span><span class="n">AttrList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object representing *all* the zAttributes in a zVariable.</span>

<span class="sd">    Normally accessed as an attribute of a :class:`Var` in an open</span>
<span class="sd">    CDF:</span>

<span class="sd">    &gt;&gt;&gt; epoch_attribs = cdffile[&#39;Epoch&#39;].attrs</span>

<span class="sd">    Appears as a dictionary: keys are attribute names, values are</span>
<span class="sd">    the value of the zEntry associated with the appropriate zVariable.</span>
<span class="sd">    Each vAttribute in a CDF may only have a *single* entry associated</span>
<span class="sd">    with each variable. The entry may be a string, a single numerical value,</span>
<span class="sd">    or a series of numerical values. Entries with multiple values are returned</span>
<span class="sd">    as an entire list; direct access to the individual elements is not</span>
<span class="sd">    possible.</span>

<span class="sd">    Example: finding the first dependency of (ISTP-compliant) variable</span>
<span class="sd">    ``Flux``:</span>

<span class="sd">    &gt;&gt;&gt; print cdffile[&#39;Flux&#39;].attrs[&#39;DEPEND_0&#39;]</span>

<span class="sd">    zAttributes are shared among zVariables, one zEntry allowed per zVariable.</span>
<span class="sd">    (pyCDF hides this detail.) Deleting the last zEntry for a zAttribute will</span>
<span class="sd">    delete the underlying zAttribute.</span>

<span class="sd">    zEntries are created and destroyed by the usual dict methods on the</span>
<span class="sd">    zAttrlist:</span>

<span class="sd">    &gt;&gt;&gt; epoch_attribs[&#39;new_entry&#39;] = [1, 2, 4] #assign a list to new zEntry</span>
<span class="sd">    &gt;&gt;&gt; del epoch_attribs[&#39;new_entry&#39;] #delete the zEntry</span>

<span class="sd">    The type of the zEntry is guessed from data provided. The type is chosen to</span>
<span class="sd">    match the data; subject to that constraint, it will try to match</span>
<span class="sd">    (in order):</span>
<span class="sd">        #. existing zEntry corresponding to this zVar</span>
<span class="sd">        #. other zEntries in this zAttribute</span>
<span class="sd">        #. the type of this zVar</span>
<span class="sd">        #. data-matching constraints described in :py:meth:`CDF.new`</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :class:`AttrList`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">AttrType</span> <span class="o">=</span> <span class="n">zAttr</span>
    <span class="n">attr_name</span> <span class="o">=</span> <span class="s1">&#39;zAttribute&#39;</span>
    <span class="n">global_scope</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zvar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the attribute collection</span>

<span class="sd">        @param zvar: zVariable these attributes are in</span>
<span class="sd">        @param zvar: :py:class:`pycdf.Var`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">zvar</span><span class="o">.</span><span class="n">cdf_file</span><span class="p">,</span> <span class="n">zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span> <span class="o">=</span> <span class="n">zvar</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find an zEntry by name</span>

<span class="sd">        @param name: name of the zAttribute to return</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @return: attribute named L{name}</span>
<span class="sd">        @rtype: L{zAttr}</span>
<span class="sd">        @raise KeyError: if there is no attribute named L{name} associated</span>
<span class="sd">                         with this zVariable</span>
<span class="sd">        @raise CDFError: other errors in CDF library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">zvar_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">attrib</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">):</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_raw</span>
            <span class="k">return</span> <span class="n">attrib</span><span class="p">[</span><span class="n">zvar_num</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: no such attribute for variable &#39;</span> <span class="o">+</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an zEntry by name</span>

<span class="sd">        @param name: name of the zEntry to delete</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @raise KeyError: if there is no attribute named L{name} associated</span>
<span class="sd">                         with this zVariable</span>
<span class="sd">        @raise CDFError: other errors in CDF library</span>
<span class="sd">        @note: If this is the only remaining entry, the Attribute will be</span>
<span class="sd">               deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">zvar_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attrib</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;: no such attribute for variable &#39;</span> <span class="o">+</span>
                           <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">attrib</span><span class="p">[</span><span class="n">zvar_num</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">_delete</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets a zEntry by name</span>

<span class="sd">        The type of the zEntry is guessed from L{data}. The type is chosen to</span>
<span class="sd">        match the data; subject to that constraint, it will try to match</span>
<span class="sd">        (in order):</span>
<span class="sd">        1. existing zEntry corresponding to this zVar</span>
<span class="sd">        2. other zEntries in this zAttribute</span>
<span class="sd">        3. the type of this zVar</span>
<span class="sd">        4. data-matching constraints described in L{_Hyperslice.types}</span>

<span class="sd">        @param name: name of zAttribute; zEntry for this zVariable will be set</span>
<span class="sd">                     in zAttribute by this name</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @raise CDFError: errors in CDF library</span>
<span class="sd">        @raise ValueError: if unable to find a valid CDF type matching L{data},</span>
<span class="sd">                           or if L{data} is the wrong dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">zAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">zvar_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_raw</span>
        <span class="n">attr</span><span class="p">[</span><span class="n">zvar_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of zAttributes in this variable</span>

<span class="sd">        @return: number of zAttributes in the CDF</span>
<span class="sd">                 which have entries for this variable.</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">const</span><span class="o">.</span><span class="n">GET_</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">CDF_NUMATTRS_</span><span class="p">,</span>
                             <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">zAttr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_file</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">candidate</span><span class="o">.</span><span class="n">global_scope</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()):</span>
                    <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find or change the CDF type of a zEntry in this zVar</span>

<span class="sd">        @param name: name of the zAttr to check or change</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param new_type: type to change it to, see :py:mod:`pycdf.const`</span>
<span class="sd">        @type new_type: ctypes.c_long</span>
<span class="sd">        @return: CDF variable type, see :py:mod:`pycdf.const`</span>
<span class="sd">        @rtype: int</span>
<span class="sd">        @note: If changing types, old and new must be equivalent, see CDF</span>
<span class="sd">               User&#39;s Guide section 2.5.5 pg. 57</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">zAttrList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">zvar_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">_num</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attrib</span><span class="o">.</span><span class="n">has_entry</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;: no such attribute for variable &#39;</span> <span class="o">+</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_zvar</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">attrib</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">zvar_num</span><span class="p">,</span> <span class="n">new_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clone_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">master</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clones a single attribute from one in this list or another</span>

<span class="sd">        Copies data and types from the master attribute to the new one</span>

<span class="sd">        @param master: attribute list to copy attribute from</span>
<span class="sd">        @type master: L{zAttrList}</span>
<span class="sd">        @param name: name of attribute to copy</span>
<span class="sd">        @type name: str</span>
<span class="sd">        @param new_name: name of the new attribute, default L{name}</span>
<span class="sd">        @type new_name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span> <span class="n">master</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                 <span class="n">master</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>


<span class="c1"># vim: set tw=79 :</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, X.Bonnin, B.Cecconi, Q.N.Nguyen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.5.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>